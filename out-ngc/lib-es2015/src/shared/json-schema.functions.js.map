{"version":3,"sources":["../../../lib/src/shared/json-schema.functions.ts"],"names":[],"mappings":"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","file":"json-schema.functions.js","sourceRoot":"","sourcesContent":["import * as _ from 'lodash/index';\r\n\r\nimport {\r\n  getType, hasValue, inArray, isString, isFunction, isObject, isArray\r\n} from './validator.functions';\r\nimport { forEach, hasOwn, mergeFilteredObject } from './utility.functions';\r\nimport { JsonPointer, Pointer } from './jsonpointer.functions';\r\nimport { JsonValidators } from './json.validators';\n/**\n * 'buildSchemaFromLayout' function\r\rBuild a JSON Schema from a JSON Form layout\r\r\\@param {any[]} layout - The JSON Form layout\r\\@return {JSON Schema} - The new JSON Schema\n * @param {?} layout\n * @return {?}\n */\nexport function buildSchemaFromLayout(layout: any[]): any {\r\n  return;\r\n  // let newSchema: any = { };\r\n  // const walkLayout = (layoutItems: any[], callback: Function): any[] => {\r\n  //   let returnArray: any[] = [];\r\n  //   for (let layoutItem of layoutItems) {\r\n  //     const returnItem: any = callback(layoutItem);\r\n  //     if (returnItem) { returnArray = returnArray.concat(callback(layoutItem)); }\r\n  //     if (layoutItem.items) {\r\n  //       returnArray = returnArray.concat(walkLayout(layoutItem.items, callback));\r\n  //     }\r\n  //   }\r\n  //   return returnArray;\r\n  // };\r\n  // walkLayout(layout, layoutItem => {\r\n  //   let itemKey: string;\r\n  //   if (typeof layoutItem === 'string') {\r\n  //     itemKey = layoutItem;\r\n  //   } else if (layoutItem.key) {\r\n  //     itemKey = layoutItem.key;\r\n  //   }\r\n  //   if (!itemKey) { return; }\r\n  //   //\r\n  // });\r\n}\n/**\n * 'buildSchemaFromData' function\r\rBuild a JSON Schema from a data object\r\r\\@param {any} data - The data object\r\\@return {JSON Schema} - The new JSON Schema\n * @param {?} data\n * @param {?=} requireAllFields\n * @param {?=} isRoot\n * @return {?}\n */\nexport function buildSchemaFromData(\r\n  data: any, requireAllFields: boolean = false, isRoot: boolean = true\r\n): any {\r\n  let /** @type {?} */ newSchema: any = { };\r\n  if (isRoot) { newSchema.$schema = 'http://json-schema.org/draft-06/schema#'; }\r\n  const /** @type {?} */ getFieldType = (value: any): string => {\r\n    let /** @type {?} */ fieldType = getType(value, 'strict');\r\n    if (fieldType === 'integer') { return 'number'; }\r\n    if (fieldType === 'null') { return 'string'; }\r\n    return fieldType;\r\n  };\r\n  newSchema.type = getFieldType(data);\r\n  if (newSchema.type === 'object') {\r\n    newSchema.properties = {};\r\n    if (requireAllFields) { newSchema.required = []; }\r\n    for (let /** @type {?} */ key of Object.keys(data)) {\r\n      newSchema.properties[key] = buildSchemaFromData(data[key], requireAllFields, false);\r\n      if (requireAllFields) { newSchema.required.push(key); }\r\n    }\r\n  } else if (newSchema.type === 'array') {\r\n    let /** @type {?} */ itemTypes: string[] = data.map(getFieldType).reduce(\r\n      (types, type) => types.concat(types.indexOf(type) === -1 ? type : [])\r\n    , []);\r\n    const /** @type {?} */ buildSubSchemaFromData = (value) => buildSchemaFromData(value, requireAllFields, false);\r\n    if (itemTypes.length === 1) {\r\n      newSchema.items = data.map(buildSubSchemaFromData).reduce(\r\n        (combined, item) => Object.assign(combined, item)\r\n      , { });\r\n    } else {\r\n      newSchema.items = data.map(buildSubSchemaFromData);\r\n    }\r\n    if (requireAllFields) { newSchema.minItems = 1; }\r\n  }\r\n  return newSchema;\r\n}\n/**\n * 'getFromSchema' function\r\rUses a JSON Pointer for a data object to retrieve a sub-schema from\ra JSON Schema which describes that data object\r\r\\@param {JSON Schema} schema - The schema to get the sub-schema from\r\\@param {Pointer} dataPointer - JSON Pointer (string or array)\r\\@param {boolean = false} returnContainer - Return containing object instead?\r\\@return {schema} - The located sub-schema\n * @param {?} schema\n * @param {?} dataPointer\n * @param {?=} returnContainer\n * @return {?}\n */\nexport function getFromSchema(\r\n  schema: any, dataPointer: Pointer, returnContainer: boolean = false\r\n): any {\r\n  const /** @type {?} */ dataPointerArray: any[] = JsonPointer.parse(dataPointer);\r\n  let /** @type {?} */ subSchema = schema;\r\n  if (dataPointerArray === null) {\r\n    console.error('getFromSchema error: Invalid JSON Pointer: ' + dataPointer);\r\n    return null;\r\n  }\r\n  const /** @type {?} */ l = returnContainer ? dataPointerArray.length - 1 : dataPointerArray.length;\r\n  for (let /** @type {?} */ i = 0; i < l; ++i) {\r\n    const /** @type {?} */ parentSchema = subSchema;\r\n    const /** @type {?} */ key = dataPointerArray[i];\r\n    let /** @type {?} */ subSchemaArray = false;\r\n    let /** @type {?} */ subSchemaObject = false;\r\n    if (typeof subSchema !== 'object') {\r\n      console.error('getFromSchema error: Unable to find \"' + key +\r\n        '\" key in schema.');\r\n      console.error(schema);\r\n      console.error(dataPointer);\r\n      return null;\r\n    }\r\n    if (subSchema['type'] === 'array' && subSchema.hasOwnProperty('items') &&\r\n      (!isNaN(key) || key === '-')\r\n    ) {\r\n      subSchema = subSchema['items'];\r\n      subSchemaArray = true;\r\n    }\r\n    if (subSchema['type'] === 'object' && subSchema.hasOwnProperty('properties')) {\r\n      subSchema = subSchema['properties'];\r\n      subSchemaObject = true;\r\n    }\r\n    if (!subSchemaArray || !subSchemaObject) {\r\n      if (subSchemaArray && key === '-') {\r\n        subSchema = (parentSchema.hasOwnProperty('additionalItems')) ?\r\n          parentSchema.additionalItems : { };\r\n      } else if (typeof subSchema === 'object' && subSchema.hasOwnProperty(key)) {\r\n        subSchema = subSchema[key];\r\n      } else {\r\n        console.error('getFromSchema error: Unable to find \"' + key +\r\n          '\" item in schema.');\r\n        console.error(schema);\r\n        console.error(dataPointer);\r\n        return;\r\n      }\r\n    }\r\n  }\r\n  return subSchema;\r\n}\n/**\n * 'getSchemaReference' function\r\rReturn the sub-section of a schema referred to\rby a JSON Pointer or '$ref' object.\r\r\\@param {object} schema - The schema to return a sub-section from\r\\@param {string|object} reference - JSON Pointer or '$ref' object\r\\@param {object} schemaRefLibrary - Optional library of resolved refernces\r\\@param {object} recursiveRefMap - Optional map of recursive links\r\\@return {object} - The refernced schema sub-section\n * @param {?} schema\n * @param {?} reference\n * @param {?=} schemaRefLibrary\n * @param {?=} recursiveRefMap\n * @return {?}\n */\nexport function getSchemaReference(\r\n  schema: any, reference: any, schemaRefLibrary: any = null,\r\n  recursiveRefMap: Map<string, string> = null\r\n): any {\r\n  let /** @type {?} */ schemaPointer: string;\r\n  let /** @type {?} */ newSchema: any;\r\n  if (isArray(reference) || typeof reference === 'string') {\r\n    schemaPointer = JsonPointer.compile(reference);\r\n  } else if (isObject(reference) && Object.keys(reference).length === 1 &&\r\n    reference.hasOwnProperty('$ref') && typeof reference.$ref === 'string'\r\n  ) {\r\n    schemaPointer = JsonPointer.compile(reference.$ref);\r\n  } else {\r\n    console.error('getSchemaReference error: ' +\r\n      'reference must be a JSON Pointer or $ref link');\r\n    console.error(reference);\r\n    return reference;\r\n  }\r\n  if (recursiveRefMap) {\r\n    schemaPointer = resolveRecursiveReferences(schemaPointer, recursiveRefMap);\r\n  }\r\n  if (schemaPointer === '') {\r\n    return _.cloneDeep(schema);\r\n  } else if (schemaRefLibrary && schemaRefLibrary.hasOwnProperty(schemaPointer)) {\r\n    return _.cloneDeep(schemaRefLibrary[schemaPointer]);\r\n\r\n  // TODO: Add ability to download remote schema, if necessary\r\n  // } else if (schemaPointer.slice(0, 4) === 'http') {\r\n  //    http.get(schemaPointer).subscribe(response => {\r\n  //     // TODO: check for recursive references\r\n  //     // TODO: test and adjust to allow for for async response\r\n  //     if (schemaRefLibrary) schemaRefLibrary[schemaPointer] = response.json();\r\n  //     return response.json();\r\n  //    });\r\n\r\n  } else {\r\n    newSchema = _.cloneDeep(JsonPointer.get(schema, schemaPointer));\r\n\r\n    // If newSchema is an allOf array, combine array elements\r\n    // TODO: Check and fix duplicate elements with different values\r\n    if (isObject(newSchema) && Object.keys(newSchema).length === 1 &&\r\n      hasOwn(newSchema, 'allOf') && isArray(newSchema.allOf)\r\n    ) {\r\n      newSchema = newSchema.allOf\r\n        .map(object => getSchemaReference(schema, object, schemaRefLibrary, recursiveRefMap))\r\n        .reduce((schema1, schema2) => Object.assign(schema1, schema2), { });\r\n    }\r\n\r\n    if (schemaRefLibrary) {\r\n      schemaRefLibrary[schemaPointer] = _.cloneDeep(newSchema);\r\n    }\r\n    return newSchema;\r\n  }\r\n}\n/**\n * 'resolveRecursiveReferences' function\r\rChecks a JSON Pointer against a map of recursive references and returns\ra JSON Pointer to the shallowest equivalent location in the same object.\r\rUsing this functions enables an object to be constructed with unlimited\rrecursion, while maintaing a fixed set of metadata, such as field data types.\rThe object can grow as large as it wants, and deeply recursed nodes can\rjust refer to the metadata for their shallow equivalents, instead of having\rto add additional redundant metadata for each recursively added node.\r\rExample:\r\rpointer:         '/stuff/and/more/and/more/and/more/and/more/stuff'\rrecursiveRefMap: [['/stuff/and/more/and/more', '/stuff/and/more/']]\rreturned:        '/stuff/and/more/stuff'\r\r\\@param  {Pointer} pointer -\r\\@param  {Map<string, string>} recursiveRefMap -\r\\@param  {Map<string, number>} arrayMap - optional\r\\@return {string} -\n * @param {?} pointer\n * @param {?} recursiveRefMap\n * @param {?=} arrayMap\n * @return {?}\n */\nexport function resolveRecursiveReferences(\r\n  pointer: Pointer, recursiveRefMap: Map<string, string>,\r\n  arrayMap: Map<string, number> = new Map<string, number>()\r\n): string {\r\n  let /** @type {?} */ genericPointer =\r\n    JsonPointer.toGenericPointer(JsonPointer.compile(pointer), arrayMap);\r\n  let /** @type {?} */ possibleReferences = true;\r\n  let /** @type {?} */ previousPointerValues: Pointer[] = [];\r\n  const /** @type {?} */ catchCircularLinks = (newPointer) => {\r\n    if (previousPointerValues.indexOf(newPointer) !== -1) {\r\n      console.error('resolveRecursiveReferences error: ' +\r\n        'recursive reference map contains circular links');\r\n      console.error(recursiveRefMap);\r\n      return;\r\n    }\r\n    previousPointerValues.push(genericPointer);\r\n    return newPointer;\r\n  };\r\n  while (possibleReferences) {\r\n    possibleReferences = false;\r\n    recursiveRefMap.forEach((toPointer, fromPointer) => {\r\n      if (JsonPointer.isSubPointer(toPointer, fromPointer)) {\r\n        while (JsonPointer.isSubPointer(fromPointer, genericPointer)) {\r\n          genericPointer = catchCircularLinks(JsonPointer.toGenericPointer(\r\n            toPointer + genericPointer.slice(fromPointer.length), arrayMap\r\n          ));\r\n          possibleReferences = true;\r\n        }\r\n      }\r\n    });\r\n  }\r\n  return genericPointer;\r\n}\n/**\n * 'getInputType' function\r\r\\@param {any} schema\r\\@return {string}\n * @param {?} schema\n * @param {?=} layoutNode\n * @return {?}\n */\nexport function getInputType(schema: any, layoutNode: any = null): string {\r\n  // x-schema-form = Angular Schema Form compatibility\r\n  // widget & component = React Jsonschema Form compatibility\r\n  let /** @type {?} */ controlType = JsonPointer.getFirst([\r\n    [schema, '/x-schema-form/type'],\r\n    [schema, '/x-schema-form/widget/component'],\r\n    [schema, '/x-schema-form/widget'],\r\n    [schema, '/widget/component'],\r\n    [schema, '/widget']\r\n  ]);\r\n  if (isString(controlType)) { return checkInlineType(controlType, schema, layoutNode); }\r\n  let /** @type {?} */ schemaType = schema.type;\r\n  if (schemaType) {\r\n    if (isArray(schemaType)) { // If multiple types listed, use most inclusive type\r\n      if (inArray('object', schemaType) && hasOwn(schema, 'properties')) {\r\n        schemaType = 'object';\r\n      } else if (inArray('array', schemaType) && hasOwn(schema, 'items')) {\r\n        schemaType = 'array';\r\n      } else if (inArray('string', schemaType)) {\r\n        schemaType = 'string';\r\n      } else if (inArray('number', schemaType)) {\r\n        schemaType = 'number';\r\n      } else if (inArray('integer', schemaType)) {\r\n        schemaType = 'integer';\r\n      } else if (inArray('boolean', schemaType)) {\r\n        schemaType = 'boolean';\r\n      } else {\r\n        schemaType = 'null';\r\n      }\r\n    }\r\n    if (schemaType === 'boolean') { return 'checkbox'; }\r\n    if (schemaType === 'object') {\r\n      if (hasOwn(schema, 'properties')) { return 'section'; }\r\n      if (hasOwn(schema, '$ref') ||\r\n      JsonPointer.has(schema, '/additionalProperties/$ref')) { return '$ref'; }\r\n      return null; // return 'textarea'; (?)\r\n    }\r\n    if (schemaType === 'array') {\r\n      let /** @type {?} */ itemsObject = JsonPointer.getFirst([\r\n        [schema, '/items'],\r\n        [schema, '/additionalItems']\r\n      ]);\r\n      if (!itemsObject) { return null; }\r\n      if (hasOwn(itemsObject, 'enum')) {\r\n        return checkInlineType('checkboxes', schema, layoutNode);\r\n      } else {\r\n        return 'array';\r\n      }\r\n    }\r\n    if (schemaType === 'null') { return 'hidden'; }\r\n    if (hasOwn(schema, 'enum')) { return 'select'; }\r\n    if (schemaType === 'number' || schemaType === 'integer') {\r\n      if (hasOwn(schema, 'maximum') && hasOwn(schema, 'minimum') &&\r\n      (schemaType === 'integer' || hasOwn(schema, 'multipleOf'))) { return 'range'; }\r\n      return schemaType;\r\n    }\r\n    if (schemaType === 'string') {\r\n      if (hasOwn(schema, 'format')) {\r\n        if (schema.format === 'color') { return 'color'; }\r\n        if (schema.format === 'date') { return 'date'; }\r\n        if (schema.format === 'date-time') { return 'datetime-local'; }\r\n        if (schema.format === 'email') { return 'email'; }\r\n        if (schema.format === 'uri') { return 'url'; }\r\n      }\r\n      return 'text';\r\n    }\r\n  }\r\n  if (hasOwn(schema, '$ref')) { return '$ref'; }\r\n  return 'text';\r\n}\n/**\n * 'checkInlineType' function\r\r\\@param {string} controlType -\r\\@param {JSON Schema} schema -\r\\@return {string}\n * @param {?} controlType\n * @param {?} schema\n * @param {?=} layoutNode\n * @return {?}\n */\nexport function checkInlineType(\r\n  controlType: string, schema: any, layoutNode: any = null\r\n): string {\r\n  if (!isString(controlType) || (\r\n    controlType.slice(0, 8) !== 'checkbox' && controlType.slice(0, 5) !== 'radio'\r\n  )) {\r\n    return controlType;\r\n  }\r\n  if (\r\n    JsonPointer.getFirst([\r\n      [layoutNode, '/inline'],\r\n      [layoutNode, '/options/inline'],\r\n      [schema, '/inline'],\r\n      [schema, '/x-schema-form/inline'],\r\n      [schema, '/x-schema-form/options/inline'],\r\n      [schema, '/x-schema-form/widget/inline'],\r\n      [schema, '/x-schema-form/widget/component/inline'],\r\n      [schema, '/x-schema-form/widget/component/options/inline'],\r\n      [schema, '/widget/inline'],\r\n      [schema, '/widget/component/inline'],\r\n      [schema, '/widget/component/options/inline'],\r\n    ]) === true\r\n  ) {\r\n    return controlType.slice(0, 5) === 'radio' ?\r\n      'radios-inline' : 'checkboxes-inline';\r\n  } else {\r\n    return controlType;\r\n  }\r\n}\n/**\n * 'isInputRequired' function\r\rChecks a JSON Schema to see if an item is required\r\r\\@param {schema} schema - the schema to check\r\\@param {string} key - the key of the item to check\r\\@return {boolean} - true if the item is required, false if not\n * @param {?} schema\n * @param {?} pointer\n * @return {?}\n */\nexport function isInputRequired(schema: any, pointer: string): boolean {\r\n  if (!isObject(schema)) {\r\n    console.error('isInputRequired error: Input schema must be an object.');\r\n    return false;\r\n  }\r\n  let /** @type {?} */ listPointerArray: string[] = JsonPointer.parse(pointer);\r\n  if (isArray(listPointerArray) && listPointerArray.length) {\r\n    let /** @type {?} */ keyName: string = listPointerArray.pop();\r\n    let /** @type {?} */ requiredList: string[];\r\n    if (listPointerArray.length) {\r\n      if (listPointerArray[listPointerArray.length - 1] === '-') {\r\n        requiredList = JsonPointer.get(schema,\r\n          listPointerArray.slice(-1).concat(['items', 'required']));\r\n      } else {\r\n        requiredList = JsonPointer.get(schema, listPointerArray.concat('required'));\r\n      }\r\n    } else {\r\n      requiredList = schema['required'];\r\n    }\r\n    if (isArray(requiredList)) { return requiredList.indexOf(keyName) !== -1; }\r\n  }\r\n  return false;\r\n};\n/**\n * 'updateInputOptions' function\r\r\\@param {any} layoutNode\r\\@param {any} schema\r\\@return {void}\n * @param {?} layoutNode\n * @param {?} schema\n * @param {?} jsf\n * @return {?}\n */\nexport function updateInputOptions(layoutNode: any, schema: any, jsf: any) {\r\n  if (!isObject(layoutNode)) { return; }\r\n  const /** @type {?} */ templatePointer = JsonPointer.get(jsf,\r\n    ['dataMap', layoutNode.dataPointer, 'templatePointer']);\r\n\r\n  // If a validator is available for a layout option,\r\n  // and not already set in the formGroup template, set it\r\n  Object.keys(layoutNode).forEach(option => {\r\n    if (option !== 'type' && isFunction(JsonValidators[option]) && (\r\n      !hasOwn(schema, option) || ( schema[option] !== layoutNode[option] &&\r\n        !(option.slice(0, 3) === 'min' && schema[option] < layoutNode[option]) &&\r\n        !(option.slice(0, 3) === 'max' && schema[option] > layoutNode[option])\r\n      )\r\n    )) {\r\n      const /** @type {?} */ validatorPointer = templatePointer + '/validators/' + option;\r\n      jsf.formGroupTemplate = JsonPointer.set(\r\n        jsf.formGroupTemplate, validatorPointer, [layoutNode[option]]\r\n      );\r\n    }\r\n  });\r\n\r\n  // Set all option values in layoutNode.options\r\n  let /** @type {?} */ newOptions: any = { };\r\n  const /** @type {?} */ fixUiKeys = (key) => key.slice(0, 3) === 'ui:' ? key.slice(3) : key;\r\n  mergeFilteredObject(newOptions, jsf.globalOptions.formDefaults,\r\n    [], fixUiKeys);\r\n  if (JsonPointer.has(schema, '/items/enum')) { newOptions.enum = schema.items.enum; }\r\n  if (JsonPointer.has(schema, '/items/titleMap')) { newOptions.enum = schema.items.titleMap; }\r\n  mergeFilteredObject(newOptions, JsonPointer.get(schema, '/ui:widget/options'),\r\n    [], fixUiKeys);\r\n  mergeFilteredObject(newOptions, JsonPointer.get(schema, '/ui:widget'),\r\n    [], fixUiKeys);\r\n  mergeFilteredObject(newOptions, schema, ['properties', 'items', 'required',\r\n    'type', 'x-schema-form', '$ref'], fixUiKeys);\r\n  mergeFilteredObject(newOptions, JsonPointer.get(schema, '/x-schema-form/options'),\r\n    [], fixUiKeys);\r\n  mergeFilteredObject(newOptions, JsonPointer.get(schema, '/x-schema-form'),\r\n    ['items', 'options'], fixUiKeys);\r\n  mergeFilteredObject(newOptions, layoutNode, ['arrayItem', 'dataPointer',\r\n    'dataType', 'items', 'layoutPointer', 'listItems', 'name', 'options',\r\n    'tupleItems', 'type', 'widget', '_id', '$ref'], fixUiKeys);\r\n  mergeFilteredObject(newOptions, layoutNode.options, [], fixUiKeys);\r\n  layoutNode.options = newOptions;\r\n\r\n  // If schema type is integer, enforce by setting multipleOf = 1\r\n  if (schema.type === 'integer' && !hasValue(layoutNode.options.multipleOf)) {\r\n    layoutNode.options.multipleOf = 1;\r\n  }\r\n\r\n  // Copy any typeahead word lists to options.typeahead.source\r\n  if (JsonPointer.has(newOptions, '/autocomplete/source')) {\r\n    newOptions.typeahead = newOptions.autocomplete;\r\n  } else if (JsonPointer.has(newOptions, '/tagsinput/source')) {\r\n    newOptions.typeahead = newOptions.tagsinput;\r\n  } else if (JsonPointer.has(newOptions, '/tagsinput/typeahead/source')) {\r\n    newOptions.typeahead = newOptions.tagsinput.typeahead;\r\n  }\r\n\r\n  // If field value is set in layoutNode, and no input data, update template value\r\n  if (templatePointer && schema.type !== 'array' && schema.type !== 'object') {\r\n    let /** @type {?} */ layoutNodeValue: any = JsonPointer.getFirst([\r\n      [ jsf.defaultValues, layoutNode.dataPointer ],\r\n      [ layoutNode, '/value' ],\r\n      [ layoutNode, '/default' ]\r\n    ]);\r\n    let /** @type {?} */ templateValue: any = JsonPointer.get(\r\n      jsf.formGroupTemplate, templatePointer + '/value/value'\r\n    );\r\n    if (hasValue(layoutNodeValue) && layoutNodeValue !== templateValue) {\r\n      jsf.formGroupTemplate = JsonPointer.set(\r\n        jsf.formGroupTemplate, templatePointer + '/value/value', layoutNodeValue\r\n      );\r\n    }\r\n    delete layoutNode.value;\r\n    delete layoutNode.default;\r\n  }\r\n}\n/**\n * 'getControlValidators' function\r\r\\@param {schema} schema\r\\@return {validators}\n * @param {?} schema\n * @return {?}\n */\nexport function getControlValidators(schema: any) {\r\n  if (!isObject(schema)) { return null; }\r\n  let /** @type {?} */ validators: any = { };\r\n  if (hasOwn(schema, 'type')) {\r\n    switch (schema.type) {\r\n      case 'string':\r\n        forEach(['pattern', 'format', 'minLength', 'maxLength'], (prop) => {\r\n          if (hasOwn(schema, prop)) { validators[prop] = [schema[prop]]; }\r\n        });\r\n      break;\r\n      case 'number': case 'integer':\r\n        forEach(['Minimum', 'Maximum'], (Limit) => {\r\n          let /** @type {?} */ eLimit = 'exclusive' + Limit;\r\n          let /** @type {?} */ limit = Limit.toLowerCase();\r\n          if (hasOwn(schema, limit)) {\r\n            let /** @type {?} */ exclusive = hasOwn(schema, eLimit) && schema[eLimit] === true;\r\n            validators[limit] = [schema[limit], exclusive];\r\n          }\r\n        });\r\n        forEach(['multipleOf', 'type'], (prop) => {\r\n          if (hasOwn(schema, prop)) { validators[prop] = [schema[prop]]; }\r\n        });\r\n      break;\r\n      case 'object':\r\n        forEach(['minProperties', 'maxProperties', 'dependencies'], (prop) => {\r\n          if (hasOwn(schema, prop)) { validators[prop] = [schema[prop]]; }\r\n        });\r\n      break;\r\n      case 'array':\r\n        forEach(['minItems', 'maxItems', 'uniqueItems'], (prop) => {\r\n          if (hasOwn(schema, prop)) { validators[prop] = [schema[prop]]; }\r\n        });\r\n      break;\r\n    }\r\n  }\r\n  if (hasOwn(schema, 'enum')) { validators['enum'] = [schema['enum']]; }\r\n  return validators;\r\n}\r\n"]}