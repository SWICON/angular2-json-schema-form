{"version":3,"sources":["../../../lib/src/shared/validator.functions.ts"],"names":[],"mappings":"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","file":"validator.functions.js","sourceRoot":"","sourcesContent":["import { AbstractControl } from '@angular/forms';\r\nimport { toPromise } from 'rxjs/operator/toPromise';\r\n\r\n/**\r\n * Validator utility function library:\r\n *\r\n * Validator and error utilities:\r\n *   _executeValidators, _executeAsyncValidators, _mergeObjects, _mergeErrors\r\n *\r\n * Individual value checking:\r\n *   isDefined, hasValue, isEmpty\r\n *\r\n * Individual type checking:\r\n *   isString, isNumber, isInteger, isBoolean, isFunction, isObject, isArray,\r\n *   isMap, isSet, isPromise\r\n *\r\n * Multiple type checking and fixing:\r\n *   getType, isType, isPrimitive, toJavaScriptType, toSchemaType, _convertToPromise\r\n *\r\n * Utility functions:\r\n *   inArray, xor\r\n *\r\n * Typescript types and interfaces:\r\n *   SchemaPrimitiveType, SchemaType, JavaScriptPrimitiveType, JavaScriptType,\r\n *   PrimitiveValue, PlainObject, IValidatorFn, AsyncIValidatorFn\r\n *\r\n * Note: 'IValidatorFn' is short for 'invertable validator function',\r\n *   which is a validator functions that accepts an optional second\r\n *   argument which, if set to TRUE, causes the validator to perform\r\n *   the opposite of its original function.\r\n */\r\n\r\nexport type SchemaPrimitiveType =\r\n  'string' | 'number' | 'integer' | 'boolean' | 'null';\r\nexport type SchemaType =\r\n  'string' | 'number' | 'integer' | 'boolean' | 'null' | 'object' | 'array';\r\nexport type JavaScriptPrimitiveType =\r\n  'string' | 'number' | 'boolean' | 'null' | 'undefined';\r\nexport type JavaScriptType =\r\n  'string' | 'number' | 'boolean' | 'null' | 'undefined' | 'object' | 'array' |\r\n  'map' | 'set' | 'arguments' | 'date' | 'error' | 'function' | 'json' |\r\n  'math' | 'regexp'; // Note: this list is incomplete\r\nexport type PrimitiveValue = string | number | boolean | null | undefined;\r\nexport type PlainObject = { [k: string]: any };\r\n\r\nexport interface IValidatorFn { (c: AbstractControl, i?: boolean): PlainObject; }\r\nexport interface AsyncIValidatorFn { (c: AbstractControl, i?: boolean): any; }\n/**\n * '_executeValidators' utility function\r\rValidates a control against an array of validators, and returns\ran array of the same length containing a combination of error messages\r(from invalid validators) and null values (from valid validators)\r\r\\@param {AbstractControl} control - control to validate\r\\@param {IValidatorFn[]} validators - array of validators\r\\@return {any[]} - array of nulls and error message\n * @param {?} control\n * @param {?} validators\n * @param {?=} invert\n * @return {?}\n */\nexport function _executeValidators(\r\n  control: AbstractControl, validators: IValidatorFn[], invert: boolean = false\r\n): PlainObject[] {\r\n  return validators.map(validator => validator(control, invert));\r\n}\n/**\n * '_executeAsyncValidators' utility function\r\rValidates a control against an array of async validators, and returns\ran array of observabe results of the same length containing a combination of\rerror messages (from invalid validators) and null values (from valid ones)\r\r\\@param {AbstractControl} control - control to validate\r\\@param {AsyncIValidatorFn[]} validators - array of async validators\r\\@return {any[]} - array of observable nulls and error message\n * @param {?} control\n * @param {?} validators\n * @param {?=} invert\n * @return {?}\n */\nexport function _executeAsyncValidators(\r\n  control: AbstractControl, validators: AsyncIValidatorFn[], invert: boolean = false\r\n): any[] {\r\n  return validators.map(v => v(control, invert));\r\n}\n/**\n * '_mergeObjects' utility function\r\rRecursively Merges one or more objects into a single object with combined keys.\rAutomatically detects and ignores null and undefined inputs.\rAlso detects duplicated boolean 'not' keys and XORs their values.\r\r\\@param {PlainObject[]} object - one or more objects to merge\r\\@return {PlainObject} - merged object\n * @param {...?} object\n * @return {?}\n */\nexport function _mergeObjects(...object: PlainObject[]): PlainObject {\r\n  let /** @type {?} */ mergedObject: PlainObject = { };\r\n  for (let /** @type {?} */ i = 0, /** @type {?} */ l = arguments.length; i < l; i++) {\r\n    const /** @type {?} */ currentObject = arguments[i];\r\n    if (isObject(currentObject)) {\r\n      for (let /** @type {?} */ key of Object.keys(currentObject)) {\r\n        const /** @type {?} */ currentValue = currentObject[key];\r\n        const /** @type {?} */ mergedValue = mergedObject[key];\r\n        if (isDefined(mergedValue)) {\r\n          if ( key === 'not' &&\r\n            isBoolean(mergedValue, 'strict') &&\r\n            isBoolean(currentValue, 'strict')\r\n          ) {\r\n            mergedObject[key] = xor(mergedValue, currentValue);\r\n          } else if (\r\n            getType(mergedValue) === 'object' &&\r\n            getType(currentValue) === 'object'\r\n          ) {\r\n            mergedObject[key] = _mergeObjects(mergedValue, currentValue);\r\n          } else {\r\n            mergedObject[key] = currentValue;\r\n          }\r\n        } else {\r\n          mergedObject[key] = currentValue;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return mergedObject;\r\n}\n/**\n * '_mergeErrors' utility function\r\rMerges an array of objects.\rUsed for combining the validator errors returned from 'executeValidators'\r\r\\@param {PlainObject[]} arrayOfErrors - array of objects\r\\@return {PlainObject} - merged object, or null if no usable input objectcs\n * @param {?} arrayOfErrors\n * @return {?}\n */\nexport function _mergeErrors(arrayOfErrors: PlainObject[]): PlainObject {\r\n  let /** @type {?} */ mergedErrors: PlainObject = _mergeObjects.apply(null, arrayOfErrors);\r\n  return isEmpty(mergedErrors) ? null : mergedErrors;\r\n}\n/**\n * 'isDefined' utility function\r\rChecks if a variable contains a value of any type.\rReturns true even for otherwise 'falsey' values of 0, '', and false.\r\r\\@param {any} object - the value to check\r\\@return {boolean} - false if undefined or null, otherwise true\n * @param {?} value\n * @return {?}\n */\nexport function isDefined(value: any): boolean {\r\n  return value !== undefined && value !== null;\r\n}\n/**\n * 'hasValue' utility function\r\rChecks if a variable contains a value.\rReturs false for null, undefined, or a zero-length strng, '',\rotherwise returns true.\r(Stricter than 'isDefined' because it also returns false for '',\rthough it stil returns true for otherwise 'falsey' values 0 and false.)\r\r\\@param {any} object - the value to check\r\\@return {boolean} - false if undefined, null, or '', otherwise true\n * @param {?} value\n * @return {?}\n */\nexport function hasValue(value: any): boolean {\r\n  return value !== undefined && value !== null && value !== '';\r\n}\n/**\n * 'isEmpty' utility function\r\rSimilar to !hasValue, but also returns true for empty arrays and objects.\r\r\\@param {any} object - the value to check\r\\@return {boolean} - false if undefined, null, or '', otherwise true\n * @param {?} value\n * @return {?}\n */\nexport function isEmpty(value: any): boolean {\r\n  if (isArray(value)) { return !value.length; }\r\n  if (isObject(value)) { return !Object.keys(value).length; }\r\n  return value === undefined || value === null || value === '';\r\n}\n/**\n * 'isString' utility function\r\rChecks if a value is a string.\r\r\\@param {any} object - the value to check\r\\@return {boolean} - true if string, false if not\n * @param {?} value\n * @return {?}\n */\nexport function isString(value: any): value is string {\r\n  return typeof value === 'string';\r\n}\n/**\n * 'isNumber' utility function\r\rChecks if a value is a regular number or a numeric string.\r\r\\@param {any} object - the value to check\r\\@param {any = false} strict - if truthy, also checks JavaScript tyoe\r\\@return {boolean} - true if number, false if not\n * @param {?} value\n * @param {?=} strict\n * @return {?}\n */\nexport function isNumber(value: any, strict: any = false): boolean {\r\n  if (strict && typeof value !== 'number') { return false; }\r\n  return !isNaN(value) && value !== value / 0;\r\n}\n/**\n * 'isInteger' utility function\r\rChecks if a value is an integer.\r\r\\@param {any} object - the value to check\r\\@param {any = false} strict - if truthy, also checks JavaScript tyoe\r\\@return {boolean} - true if number, false if not\n * @param {?} value\n * @param {?=} strict\n * @return {?}\n */\nexport function isInteger(value: any, strict: any = false): boolean {\r\n  if (strict && typeof value !== 'number') { return false; }\r\n  return !isNaN(value) &&  value !== value / 0 && value % 1 === 0;\r\n}\n/**\n * 'isBoolean' utility function\r\rChecks if a value is a boolean.\r\r\\@param {any} object - the value to check\r\\@param {any = null} option - if 'strict', also checks JavaScript type\r                             if TRUE or FALSE, checks only for that value\r\\@return {boolean} - true if boolean, false if not\n * @param {?} value\n * @param {?=} option\n * @return {?}\n */\nexport function isBoolean(value: any, option: any = null): boolean {\r\n  if (option === 'strict') { return value === true || value === false; }\r\n  if (option === true) {\r\n    return value === true || value === 1 || value === 'true' || value === '1';\r\n  }\r\n  if (option === false) {\r\n    return value === false || value === 0 || value === 'false' || value === '0';\r\n  }\r\n  return value === true || value === 1 || value === 'true' || value === '1' ||\r\n    value === false || value === 0 || value === 'false' || value === '0';\r\n}\n/**\n * @param {?} item\n * @return {?}\n */\nexport function isFunction(item: any): boolean {\r\n  return typeof item === 'function';\r\n}\n/**\n * @param {?} item\n * @return {?}\n */\nexport function isObject(item: any): boolean {\r\n  return item !== null && typeof item === 'object' &&\r\n    Object.prototype.toString.call(item) === '[object Object]';\r\n}\n/**\n * @param {?} item\n * @return {?}\n */\nexport function isArray(item: any): boolean {\r\n  return Array.isArray(item) ||\r\n    Object.prototype.toString.call(item) === '[object Array]';\r\n}\n/**\n * @param {?} item\n * @return {?}\n */\nexport function isMap(item: any): boolean {\r\n  return typeof item === 'object' &&\r\n    Object.prototype.toString.call(item) === '[object Map]';\r\n}\n/**\n * @param {?} item\n * @return {?}\n */\nexport function isSet(item: any): boolean {\r\n  return typeof item === 'object' &&\r\n    Object.prototype.toString.call(item) === '[object Set]';\r\n}\n/**\n * 'getType' function\r\rDetects the JSON Schema Type of a value.\rBy default, detects numbers and integers even if formatted as strings.\r(So all integers are also numbers, and any number may also be a string.)\rHowever, it only detects true boolean values (to detect boolean values\rin non-boolean formats, use isBoolean() instead).\r\rIf passed a second optional parameter of 'strict', it will only detect\rnumbers and integers if they are JavaScript numbers.\r\rExamples:\rgetType('10.5') = 'number'\rgetType(10.5) = 'number'\rgetType('10') = 'integer'\rgetType(10) = 'integer'\rgetType('true') = 'string'\rgetType(true) = 'boolean'\rgetType(null) = 'null'\rgetType({ }) = 'object'\rgetType([]) = 'array'\r\rgetType('10.5', 'strict') = 'string'\rgetType(10.5, 'strict') = 'number'\rgetType('10', 'strict') = 'string'\rgetType(10, 'strict') = 'integer'\rgetType('true', 'strict') = 'string'\rgetType(true, 'strict') = 'boolean'\r\r\\@param {any} value - value to check\r\\@param {any = false} strict - if truthy, also checks JavaScript tyoe\r\\@return {boolean}\n * @param {?} value\n * @param {?=} strict\n * @return {?}\n */\nexport function getType(value: any, strict: any = false): SchemaType {\r\n  if (!isDefined(value)) { return 'null'; }\r\n  if (isArray(value)) { return 'array'; }\r\n  if (isObject(value)) { return 'object'; }\r\n  if (isBoolean(value, 'strict')) { return 'boolean'; }\r\n  if (isInteger(value, strict)) { return 'integer'; }\r\n  if (isNumber(value, strict)) { return 'number'; }\r\n  if (isString(value)) { return 'string'; }\r\n  return null;\r\n}\n/**\n * 'isType' function\r\rChecks wether an input (probably string) value contains data of\ra specified JSON Schema type\r\r\\@param {PrimitiveValue} value - value to check\r\\@param {SchemaPrimitiveType} type - type to check\r\\@return {boolean}\n * @param {?} value\n * @param {?} type\n * @return {?}\n */\nexport function isType(value: PrimitiveValue, type: SchemaPrimitiveType): boolean {\r\n  switch (type) {\r\n    case 'string':\r\n      return isString(value);\r\n    case 'number':\r\n      return isNumber(value);\r\n    case 'integer':\r\n      return isInteger(value);\r\n    case 'boolean':\r\n      return isBoolean(value);\r\n    case 'null':\r\n      return !hasValue(value);\r\n    default:\r\n      console.error('isType error: \"' + type + '\" is not a recognized type.');\r\n      return null;\r\n  }\r\n}\n/**\n * 'isPrimitive' function\r\rChecks wether an input value is a JavaScript primitive type:\rstring, number, boolean, or null.\r\r\\@param {any} value - value to check\r\\@return {boolean}\n * @param {?} value\n * @return {?}\n */\nexport function isPrimitive(value: any): boolean {\r\n  return (isString(value) || isNumber(value) ||\r\n    isBoolean(value, 'strict') || value === null);\r\n}\n/**\n * 'toJavaScriptType' function\r\rConverts an input (probably string) value to a JavaScript primitive type -\r'string', 'number', 'boolean', or 'null' - before storing in a JSON object.\r\rDoes not coerce values (other than null), and only converts the types\rof values that would otherwise be valid.\r\rIf the optional third parameter 'strictIntegers' is TRUE, and the\rJSON Schema type 'integer' is specified, it also verifies the input value\ris an integer and, if it is, returns it as a JaveScript number.\rIf 'strictIntegers' is FALSE (or not set) the type 'integer' is treated\rexactly the same as 'number', and allows decimals.\r\rExamples:\rtoJavaScriptType('10', 'number') = 10\rtoJavaScriptType('10', 'integer') = 10\rtoJavaScriptType('10.5', 'number') = 10.5\rtoJavaScriptType('10.5', 'integer') = null // '10.5' is not an integer\rtoJavaScriptType(10.5, 'integer') = null // 10.5 is still not an integer\r\r\\@param {PrimitiveValue} value - value to convert\r\\@param {SchemaPrimitiveType | SchemaPrimitiveType[]} types - types to convert to\r\\@param {boolean = false} strictIntegers - if FALSE, treat integers as numbers\r\\@return {boolean}\n * @param {?} value\n * @param {?} types\n * @param {?=} strictIntegers\n * @return {?}\n */\nexport function toJavaScriptType(\r\n  value: any,\r\n  types: SchemaPrimitiveType | SchemaPrimitiveType[],\r\n  strictIntegers: boolean = true\r\n): PrimitiveValue {\r\n  if (!isDefined(value)) { return null; }\r\n  if (isString(types)) { types = [types]; }\r\n  if (strictIntegers && inArray('integer', types)) {\r\n    if (isInteger(value, 'strict')) { return value; }\r\n    if (isInteger(value)) { return parseInt(value, 10); }\r\n  }\r\n  if (inArray('number', types) || (!strictIntegers && inArray('integer', types))) {\r\n    if (isNumber(value, 'strict')) { return value; }\r\n    if (isNumber(value)) { return parseFloat(value); }\r\n  }\r\n  if (inArray('string', types)) {\r\n    if (isString(value)) { return value; }\r\n  }\r\n  if (inArray('boolean', types)) {\r\n    if (isBoolean(value, true)) { return true; }\r\n    if (isBoolean(value, false)) { return false; }\r\n  }\r\n  return null;\r\n}\n/**\n * 'toSchemaType' function\r\rConverts an input (probably string) value to the \"best\" JavaScript\requivalent available from an allowed list of JSON Schema types, which may\rcontain 'string', 'number', 'integer', 'boolean', and/or 'null'.\rIf necssary, it does progressively agressive type coersion.\rIt will not return null unless null is in the list of allowed types.\r\rNumber conversion examples:\rtoSchemaType('10', ['number','integer','string']) = 10 // integer\rtoSchemaType('10', ['number','string']) = 10 // number\rtoSchemaType('10', ['string']) = '10' // string\rtoSchemaType('10.5', ['number','integer','string']) = 10.5 // number\rtoSchemaType('10.5', ['integer','string']) = '10.5' // string\rtoSchemaType('10.5', ['integer']) = 10 // integer\rtoSchemaType(10.5, ['null','boolean','string']) = '10.5' // string\rtoSchemaType(10.5, ['null','boolean']) = true // boolean\r\rString conversion examples:\rtoSchemaType('1.5x', ['boolean','number','integer','string']) = '1.5x' // string\rtoSchemaType('1.5x', ['boolean','number','integer']) = '1.5' // number\rtoSchemaType('1.5x', ['boolean','integer']) = '1' // integer\rtoSchemaType('1.5x', ['boolean']) = true // boolean\rtoSchemaType('xyz', ['number','integer','boolean','null']) = true // boolean\rtoSchemaType('xyz', ['number','integer','null']) = null // null\rtoSchemaType('xyz', ['number','integer']) = 0 // number\r\rBoolean conversion examples:\rtoSchemaType('1', ['integer','number','string','boolean']) = 1 // integer\rtoSchemaType('1', ['number','string','boolean']) = 1 // number\rtoSchemaType('1', ['string','boolean']) = '1' // string\rtoSchemaType('1', ['boolean']) = true // boolean\rtoSchemaType('true', ['number','string','boolean']) = 'true' // string\rtoSchemaType('true', ['boolean']) = true // boolean\rtoSchemaType('true', ['number']) = 0 // number\rtoSchemaType(true, ['number','string','boolean']) = true // boolean\rtoSchemaType(true, ['number','string']) = 'true' // string\rtoSchemaType(true, ['number']) = 1 // number\r\r\\@param {PrimitiveValue} value - value to convert\r\\@param {SchemaPrimitiveType[]} types - allowed types to convert to\r\\@return {boolean}\n * @param {?} value\n * @param {?} types\n * @return {?}\n */\nexport function toSchemaType(\r\n  value: PrimitiveValue, types: SchemaPrimitiveType | SchemaPrimitiveType[]\r\n): PrimitiveValue {\r\n  if (!isArray( /** @type {?} */((<SchemaPrimitiveType>types)))) {\r\n    types = /** @type {?} */(( <SchemaPrimitiveType[]>[types]));\r\n  }\r\n  if (( /** @type {?} */((<SchemaPrimitiveType[]>types))).indexOf('null') !== -1 && !hasValue(value)) {\r\n    return null;\r\n  }\r\n  if (( /** @type {?} */((<SchemaPrimitiveType[]>types))).indexOf('boolean') !== -1 && !isBoolean(value, 'strict')) {\r\n    return value;\r\n  }\r\n  if (( /** @type {?} */((<SchemaPrimitiveType[]>types))).indexOf('integer') !== -1) {\r\n    let /** @type {?} */ testValue = toJavaScriptType(value, 'integer');\r\n    if (testValue !== null) { return +testValue; }\r\n  }\r\n  if (( /** @type {?} */((<SchemaPrimitiveType[]>types))).indexOf('number') !== -1) {\r\n    let /** @type {?} */ testValue = toJavaScriptType(value, 'number');\r\n    if (testValue !== null) { return +testValue; }\r\n  }\r\n  if (\r\n    (isString(value) || isNumber(value, 'strict')) &&\r\n    ( /** @type {?} */((<SchemaPrimitiveType[]>types))).indexOf('string') !== -1\r\n  ) { // Convert number to string\r\n    return toJavaScriptType(value, 'string');\r\n  }\r\n  if (( /** @type {?} */((<SchemaPrimitiveType[]>types))).indexOf('boolean') !== -1 && isBoolean(value)) {\r\n    return toJavaScriptType(value, 'boolean');\r\n  }\r\n  if (( /** @type {?} */((<SchemaPrimitiveType[]>types))).indexOf('string') !== -1) { // Convert null & boolean to string\r\n    if (value === null) { return ''; }\r\n    let /** @type {?} */ testValue = toJavaScriptType(value, 'string');\r\n    if (testValue !== null) { return testValue; }\r\n  }\r\n  if ((\r\n    ( /** @type {?} */((<SchemaPrimitiveType[]>types))).indexOf('number') !== -1 ||\r\n    ( /** @type {?} */((<SchemaPrimitiveType[]>types))).indexOf('integer') !== -1)\r\n  ) {\r\n    if (value === true) { return 1; } // Convert boolean & null to number\r\n    if (value === false || value === null || value === '') { return 0; }\r\n  }\r\n  if (( /** @type {?} */((<SchemaPrimitiveType[]>types))).indexOf('number') !== -1) { // Convert mixed string to number\r\n    let /** @type {?} */ testValue = parseFloat( /** @type {?} */((<string>value)));\r\n    if (!!testValue) { return testValue; }\r\n  }\r\n  if (( /** @type {?} */((<SchemaPrimitiveType[]>types))).indexOf('integer') !== -1) { // Convert string or number to integer\r\n    let /** @type {?} */ testValue = parseInt( /** @type {?} */((<string>value)), 10);\r\n    if (!!testValue) { return testValue; }\r\n  }\r\n  if (( /** @type {?} */((<SchemaPrimitiveType[]>types))).indexOf('boolean') !== -1) { // Convert anything to boolean\r\n    return !!value;\r\n  }\r\n  if ((\r\n      ( /** @type {?} */((<SchemaPrimitiveType[]>types))).indexOf('number') !== -1 ||\r\n      ( /** @type {?} */((<SchemaPrimitiveType[]>types))).indexOf('integer') !== -1\r\n    ) && ( /** @type {?} */((<SchemaPrimitiveType[]>types))).indexOf('null') === -1\r\n  ) {\r\n    return 0; // If null not allowed, return 0 for non-convertable values\r\n  }\r\n}\n/**\n * 'isPromise' function\r\r\\@param {object} object\r\\@return {object}\n * @param {?} object\n * @return {?}\n */\nexport function isPromise(object: any): object is Promise<any> {\r\n  return !!object && typeof object.then === 'function';\r\n}\n/**\n * '_convertToPromise' function\r\r\\@param {object} object\r\\@return {Promise<any>}\n * @param {?} object\n * @return {?}\n */\nexport function _convertToPromise(object: any): Promise<any> {\r\n  return isPromise(object) ? object : toPromise.call(object);\r\n}\n/**\n * 'inArray' function\r\rSearches an array for an item, or one of a list of items, and returns true\ras soon as a match is found, or false if no match.\r\rIf the optional third parameter allIn is set to TRUE, and the item to find\ris an array, then the function returns true only if all elements from item\rare found in the list, and false if any element is not found. If the item to\rfind is not an array, setting allIn to TRUE has no effect.\r\r\\@param {any|any[]} item - the item to search for\r\\@param {any[]} array - the array to search\r\\@param {boolean = false} allIn - if TRUE, all items must be in array\r\\@return {boolean} - true if item(s) in array, false otherwise\n * @param {?} item\n * @param {?} array\n * @param {?=} allIn\n * @return {?}\n */\nexport function inArray(\r\n  item: any|any[], array: any[], allIn: boolean = false\r\n): boolean {\r\n  if (!isDefined(item) || !isArray(array)) { return false; }\r\n  if (isArray(item)) {\r\n    for (let /** @type {?} */ subItem of item) {\r\n      if (xor(array.indexOf(subItem) !== -1, allIn)) { return !allIn; }\r\n    }\r\n    return allIn;\r\n  } else {\r\n    return array.indexOf(item) !== -1;\r\n  }\r\n}\n/**\n * 'xor' utility function - exclusive or\r\rReturns true if exactly one of two values is truthy.\r\r\\@param {any} value1 - first value to check\r\\@param {any} value2 - second value to check\r\\@return {boolean} - true if exactly one input value is truthy, false if not\n * @param {?} value1\n * @param {?} value2\n * @return {?}\n */\nexport function xor(value1: any, value2: any): boolean {\r\n  return (!!value1 && !value2) || (!value1 && !!value2);\r\n}\r\n"]}