{"version":3,"sources":["../../../lib/src/shared/json.validators.ts"],"names":[],"mappings":"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","file":"json.validators.js","sourceRoot":"","sourcesContent":["import { AbstractControl } from '@angular/forms';\r\n\r\nimport {\r\n  _convertToPromise, _executeValidators, _executeAsyncValidators, _mergeObjects,\r\n  _mergeErrors, isEmpty, isDefined, hasValue, isString, isNumber, isBoolean,\r\n  isArray, getType, isType, toJavaScriptType, xor,\r\n  SchemaPrimitiveType, PlainObject, IValidatorFn, AsyncIValidatorFn\r\n} from './validator.functions';\r\nimport { forEachCopy } from './utility.functions';\n/**\n * 'JsonValidators' class\r\rProvides an extended set of validators to be used by form controls,\rcompatible with standard JSON Schema validation options.\rhttp://json-schema.org/latest/json-schema-validation.html\r\rNote: This library is designed as a drop-in replacement for the Angular\rValidators library, and except for one small breaking change to the 'pattern'\rvalidator (described below) it can even be imported as a substitute, like so:\r\r  import { JsonValidators as Validators } from 'json-validators';\r\rand it should work with existing code as a complete replacement.\r\rThe one exception is the 'pattern' validator, which has been changed to\rmatche partial values by default (the standard 'pattern' validator wrapped\rall patterns in '^' and '$', forcing them to always match an entire value).\rHowever, the old behavior can be restored by simply adding '^' and '$'\raround your patterns, or by passing an optional second parameter of TRUE.\rThis change is to make the 'pattern' validator match the behavior of a\rJSON Schema pattern, which allows partial matches, rather than the behavior\rof an HTML input control pattern, which does not.\r\rThis library replaces Angular's 4 validators and 1 validator combination\rfunction with the following 16 validators and 4 transformation functions:\r\rValidators:\rFor all formControls:     required (*), type, enum\rFor text formControls:    minLength (*), maxLength (*), pattern (*), format\rFor numeric formControls: minimum, maximum, multipleOf\rFor formGroup objects:    minProperties, maxProperties, dependencies\rFor formArray arrays:     minItems, maxItems, uniqueItems\r(Validators originally included with Angular are maked with (*).)\r\rNOTE: The dependencies validator is not complete.\rNOTE: The enum validator does not yet work with objects.\r\rValidator transformation functions:\r  composeAnyOf, composeOneOf, composeAllOf, composeNot\r(Angular's original combination funciton, 'compose', is also included for\rbackward compatibility, though it is effectively equivalent to composeAllOf,\rthough with a more generic error message.)\r\rAll validators have also been extended to accept an optional second argument\rwhich, if passed a TRUE value, causes the validator to perform the opposite\rof its original finction. (This is used internally to enable 'not' and\r'composeOneOf' to function and return useful error messages.)\r\rThe 'required' validator has also been overloaded so that if called with\ra boolean parameter (or no parameters) it returns the original validator\rfunction (rather than executing it). However, if it is called with an\rAbstractControl parameter (as was previously required), it behaves\rexactly as before.\r\rThis enables all validators (including 'required') to be constructed in\rexactly the same way, so they can be automatically applied using the\requivalent key names and values taken directly from a JSON Schema.\r\rThis source code is partially derived from Angular,\rwhich is Copyright (c) 2014-2016 Google, Inc.\rUse of this source code is therefore governed by the same MIT-style license\rthat can be found in the LICENSE file at https://angular.io/license\n */\nexport class JsonValidators {\r\n\r\n  /**\r\n   * Validator functions:\r\n   *\r\n   * For all formControls:     required, type, enum\r\n   * For text formControls:    minLength, maxLength, pattern, format\r\n   * For numeric formControls: minimum, maximum, multipleOf\r\n   * For formGroup objects:    minProperties, maxProperties, dependencies\r\n   * For formArray arrays:     minItems, maxItems, uniqueItems\r\n   *\r\n   * TODO: finish dependencies validator\r\n   * TODO: update enum to work with formGroup objects\r\n   */\r\n\r\n  /**\r\n   * 'required' validator\r\n   *\r\n   * This validator is overloaded, compared to the default required validator.\r\n   * If called with no parameters, or TRUE, this validator returns the\r\n   * 'required' validator function (rather than executing it). This matches\r\n   * the behavior of all other validators in this library.\r\n   *\r\n   * If this validator is called with an AbstractControl parameter\r\n   * (as was previously required) it behaves the same as Angular's default\r\n   * required validator, and returns an error if the control is empty.\r\n   *\r\n   * Old behavior: (if input type = AbstractControl)\r\n   * @param {AbstractControl} control - required control\r\n   * @return {{[key: string]: boolean}} - returns error message if no input\r\n   *\r\n   * New behavior: (if no input, or input type = boolean)\r\n   * @param {boolean = true} required? - true to validate, false to disable\r\n   * @return {IValidatorFn} - returns the 'required' validator function itself\r\n   */\r\n  static required(input: AbstractControl): PlainObject;\r\n  static required(input?: boolean): IValidatorFn;\n/**\n * @param {?=} input\n * @return {?}\n */\nstatic required(input?: AbstractControl | boolean): PlainObject | IValidatorFn {\r\n    if (input === undefined) { input = true; }\r\n    switch (input) {\r\n      case true: // Return required function (do not execute it yet)\r\n        return (control: AbstractControl, invert: boolean = false): PlainObject => {\r\n          if (invert) { return null; } // if not required, always return valid\r\n          return hasValue(control.value) ? null : { 'required': true };\r\n        };\r\n      case false: // Do nothing\r\n        return (control: AbstractControl): PlainObject => null;\r\n      default: // Execute required function\r\n        return hasValue(( /** @type {?} */((<AbstractControl>input))).value) ?\r\n          null : { 'required': true };\r\n    }\r\n  };\n/**\n * 'type' validator\r\rRequires a control to only accept values of a specified type,\ror one of an array of types.\r\rNote: SchemaPrimitiveType = 'string'|'number'|'integer'|'boolean'|'null'\r\r\\@param {SchemaPrimitiveType | SchemaPrimitiveType[]} type - type(s) to accept\r\\@return {IValidatorFn}\n * @param {?} type\n * @return {?}\n */\nstatic type(type: SchemaPrimitiveType | SchemaPrimitiveType[]): IValidatorFn {\r\n    return (control: AbstractControl, invert: boolean = false): PlainObject => {\r\n      if (isEmpty(control.value)) { return null; }\r\n      let /** @type {?} */ actualValue: any = control.value;\r\n      let /** @type {?} */ typeArray: SchemaPrimitiveType[] = isArray(type) ? /** @type {?} */((\r\n        <SchemaPrimitiveType[]>type)) : [ /** @type {?} */((<SchemaPrimitiveType>type))];\r\n      let /** @type {?} */ isValid: boolean = false;\r\n      for (let /** @type {?} */ typeValue of typeArray) {\r\n        if (isType(actualValue, typeValue) === true) {\r\n          isValid = true; break;\r\n        }\r\n      }\r\n      return xor(isValid, invert) ?\r\n        null : { 'type': { type, actualValue } };\r\n    };\r\n  }\n/**\n * 'enum' validator\r\rRequires a control to have a value from an enumerated list of values.\r\rConverts types as needed to allow string inputs to still correctly\rmatch number, boolean, and null enum values.\r(toJavaScriptType() can be used later to convert these string values.)\r\rTODO: modify to work with objects\r\r\\@param {any[]} enumList - array of acceptable values\r\\@return {IValidatorFn}\n * @param {?} enumList\n * @return {?}\n */\nstatic enum(enumList: any[]): IValidatorFn {\r\n    return (control: AbstractControl, invert: boolean = false): PlainObject => {\r\n      if (isEmpty(control.value)) { return null; }\r\n      let /** @type {?} */ isValid: boolean = true;\r\n      let /** @type {?} */ actualValues: any | any[] = (isArray(control.value)) ?\r\n        control.value : [control.value];\r\n      for (let /** @type {?} */ i1 = 0, /** @type {?} */ l1 = actualValues.length; i1 < l1; i1++) {\r\n        let /** @type {?} */ actualValue: any = actualValues[i1];\r\n        let /** @type {?} */ itemIsValid: boolean = false;\r\n        for (let /** @type {?} */ i2 = 0, /** @type {?} */ l2 = enumList.length; i2 < l2; i2++) {\r\n          let /** @type {?} */ enumValue: any = enumList[i2];\r\n          if (actualValue === enumValue) {\r\n            itemIsValid = true; break;\r\n          } else if (isNumber(enumValue) && +actualValue === +enumValue) {\r\n            itemIsValid = true; break;\r\n          } else if (\r\n            isBoolean(enumValue, 'strict') &&\r\n            toJavaScriptType(actualValue, 'boolean') === enumValue\r\n          ) {\r\n            itemIsValid = true; break;\r\n          } else if (enumValue === null && !hasValue(actualValue)) {\r\n            itemIsValid = true; break;\r\n          }\r\n        }\r\n        if (!itemIsValid) { isValid = false; break; }\r\n      }\r\n      return xor(isValid, invert) ?\r\n        null : { 'enum': { 'enum': enumList, 'actualValue': control.value } };\r\n    };\r\n  }\n/**\n * 'minLength' validator\r\rRequires a control's text value to be greater than a specified length.\r\r\\@param {number} requiredLength - minimum allowed string length\r\\@param {boolean = false} invert - instead return error object only if valid\r\\@return {IValidatorFn}\n * @param {?} requiredLength\n * @return {?}\n */\nstatic minLength(requiredLength: number): IValidatorFn {\r\n    return (control: AbstractControl, invert: boolean = false): PlainObject => {\r\n      if (isEmpty(control.value)) { return null; }\r\n      let /** @type {?} */ actualLength: number = isString(control.value) ? control.value.length : 0;\r\n      let /** @type {?} */ isValid: boolean = actualLength >= requiredLength;\r\n      return xor(isValid, invert) ?\r\n        null :\r\n        { 'minlength': { requiredLength, actualLength } };\r\n    };\r\n  };\n/**\n * 'maxLength' validator\r\rRequires a control's text value to be less than a specified length.\r\r\\@param {number} requiredLength - maximum allowed string length\r\\@param {boolean = false} invert - instead return error object only if valid\r\\@return {IValidatorFn}\n * @param {?} requiredLength\n * @return {?}\n */\nstatic maxLength(requiredLength: number): IValidatorFn {\r\n    return (control: AbstractControl, invert: boolean = false): PlainObject => {\r\n      let /** @type {?} */ actualLength: number = isString(control.value) ? control.value.length : 0;\r\n      let /** @type {?} */ isValid: boolean = actualLength <= requiredLength;\r\n      return xor(isValid, invert) ?\r\n        null :\r\n        { 'maxlength': { requiredLength, actualLength } };\r\n    };\r\n  };\n/**\n * 'pattern' validator\r\rNote: NOT the same as Angular's default pattern validator.\rRequires a control's value to match a specified regular expression pattern.\r\rThis validator changes the behavior of default pattern validator\rby replacing RegExp(`^${pattern}$`) with RegExp(`${pattern}`),\rwhich allows for partial matches.\r\rTo return to the default funcitonality, and match the entire string,\rpass TRUE as the optional second parameter.\r\r\\@param {string} pattern - regular expression pattern\r\\@param {boolean = false} wholeString - match whole value string?\r\\@return {IValidatorFn}\n * @param {?} pattern\n * @param {?=} wholeString\n * @return {?}\n */\nstatic pattern(pattern: string, wholeString: boolean = false): IValidatorFn {\r\n    return (control: AbstractControl, invert: boolean = false): PlainObject => {\r\n      if (isEmpty(control.value)) { return null; }\r\n      let /** @type {?} */ actualValue: string = control.value;\r\n      let /** @type {?} */ requiredPattern: string = (wholeString) ? `^${pattern}$` : pattern;\r\n      let /** @type {?} */ regex = new RegExp(requiredPattern);\r\n      let /** @type {?} */ isValid: boolean = isString(actualValue) ? regex.test(actualValue) : false;\r\n      return xor(isValid, invert) ?\r\n        null : { 'pattern': { requiredPattern, actualValue } };\r\n    };\r\n  }\n/**\n * 'format' validator\r\rRequires a control to have a value of a certain format.\r\rThis validator currently checks the following formsts:\r'date-time'|'email'|'hostname'|'ipv4'|'ipv6'|'uri'\r\rTODO: add 'regex' and 'color' formats\r\r\\@param {'date-time'|'email'|'hostname'|'ipv4'|'ipv6'|'uri'} format - format to check\r\\@return {IValidatorFn}\n * @param {?} format\n * @return {?}\n */\nstatic format(\r\n    format: 'date-time' | 'email' | 'hostname' | 'ipv4' | 'ipv6' | 'uri' | 'url' | 'color'\r\n  ): IValidatorFn {\r\n    return (control: AbstractControl, invert: boolean = false): PlainObject => {\r\n      if (isEmpty(control.value)) { return null; }\r\n      let /** @type {?} */ isValid: boolean;\r\n      let /** @type {?} */ actualValue: string = control.value;\r\n      if (!isString(actualValue)) {\r\n        isValid = false;\r\n      } else {\r\n        switch (format) {\r\n          case 'date-time':\r\n            isValid = !!actualValue.match(/^([0-9]+)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])[Tt]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.[0-9]+)?(([Zz])|([\\+|\\-]([01][0-9]|2[0-3]):[0-5][0-9]))$/);\r\n            break;\r\n          case 'email':\r\n            let /** @type {?} */ parts: string[] = actualValue.split('@');\r\n            isValid =\r\n              !!parts && parts.length === 2 &&\r\n              !!parts[0].match(/^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")$/)\r\n              &&\r\n              !!parts[1].match(/(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|\\b-){0,61}[0-9A-Za-z])?(?:\\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|\\b-){0,61}[0-9A-Za-z])?)*\\.?/);\r\n            break;\r\n          case 'hostname':\r\n            isValid = !!actualValue.match(/(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|\\b-){0,61}[0-9A-Za-z])?(?:\\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|\\b-){0,61}[0-9A-Za-z])?)*\\.?/);\r\n            break;\r\n          case 'ipv4':\r\n            isValid = !!actualValue.match(/^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/);\r\n            break;\r\n          case 'ipv6':\r\n            isValid = !!actualValue.match(/(([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))/);\r\n            break;\r\n          case 'uri': case 'url':\r\n            isValid = !!actualValue.match(/^((([A-Za-z]{3,9}:(?:\\/\\/)?)(?:[\\-;:&=\\+\\$,\\w]+@)?[A-Za-z0-9\\.\\-]+|(?:www\\.|[\\-;:&=\\+\\$,\\w]+@)[A-Za-z0-9\\.\\-]+)((?:\\/[\\+~%\\/\\.\\w\\-_]*)?\\??(?:[\\-\\+=&;%@\\.\\w_]*)#?(?:[\\.\\!\\/\\\\\\w]*))?)$/);\r\n            break;\r\n          case 'color':\r\n            isValid = !!actualValue.match(/^#[A-Fa-f0-9]{6}$/);\r\n            break;\r\n          default:\r\n            console.error(`format validator error: \"${format}\" is not a recognized format.`);\r\n            isValid = true;\r\n        }\r\n      }\r\n      return xor(isValid, invert) ?\r\n        null : { 'format': { format, actualValue } };\r\n    };\r\n  }\n/**\n * 'minimum' validator\r\rRequires a control to have a numeric value not greater than\ra specified minimum amount.\r\rThe optional second parameter indicates whether the valid range excludes\rthe minimum value. It defaults to false, and includes the minimum.\r\r\\@param {number} minimum - minimum allowed value\r\\@param {boolean = false} exclusiveMinimum - include minimum value itself?\r\\@return {IValidatorFn}\n * @param {?} minimum\n * @param {?=} exclusiveMinimum\n * @return {?}\n */\nstatic minimum(minimum: number, exclusiveMinimum: boolean = false): IValidatorFn {\r\n    return (control: AbstractControl, invert: boolean = false): PlainObject => {\r\n      if (isEmpty(control.value)) { return null; }\r\n      let /** @type {?} */ actualValue: number = control.value;\r\n      let /** @type {?} */ isValid: boolean = isNumber(actualValue) &&\r\n        exclusiveMinimum ? actualValue > minimum : actualValue >= minimum;\r\n      return xor(isValid, invert) ?\r\n        null : { 'minimum': { minimum, exclusiveMinimum, actualValue } };\r\n    };\r\n  }\n/**\n * 'maximum' validator\r\rRequires a control to have a numeric value not less than\ra specified maximum amount.\r\rThe optional second parameter indicates whether the valid range excludes\rthe maximum value. It defaults to false, and includes the maximum.\r\r\\@param {number} maximum - maximum allowed value\r\\@param {boolean = false} exclusiveMaximum - include maximum value itself?\r\\@return {IValidatorFn}\n * @param {?} maximum\n * @param {?=} exclusiveMaximum\n * @return {?}\n */\nstatic maximum(maximum: number, exclusiveMaximum: boolean = false): IValidatorFn {\r\n    return (control: AbstractControl, invert: boolean = false): PlainObject => {\r\n      if (isEmpty(control.value)) { return null; }\r\n      let /** @type {?} */ actualValue: number = control.value;\r\n      let /** @type {?} */ isValid: boolean = isNumber(actualValue) &&\r\n        exclusiveMaximum ? actualValue < maximum : actualValue <= maximum;\r\n      return xor(isValid, invert) ?\r\n        null : { 'maximum': { maximum, exclusiveMaximum, actualValue } };\r\n    };\r\n  }\n/**\n * 'multipleOf' validator\r\rRequires a control to have a numeric value that is a multiple\rof a specified number.\r\r\\@param {number} multipleOf - number value must be a multiple of\r\\@return {IValidatorFn}\n * @param {?} multipleOf\n * @return {?}\n */\nstatic multipleOf(multipleOf: number): IValidatorFn {\r\n    return (control: AbstractControl, invert: boolean = false): PlainObject => {\r\n      if (isEmpty(control.value)) { return null; }\r\n      let /** @type {?} */ actualValue: number = control.value;\r\n      let /** @type {?} */ isValid: boolean = isNumber(actualValue) && actualValue % multipleOf === 0;\r\n      return xor(isValid, invert) ?\r\n        null : { 'multipleOf': { multipleOf, actualValue } };\r\n    };\r\n  }\n/**\n * 'minProperties' validator\r\rRequires a form group to have a minimum number of properties (i.e. have\rvalues entered in a minimum number of controls within the group).\r\r\\@param {number} minProperties - minimum number of properties allowed\r\\@return {IValidatorFn}\n * @param {?} minProperties\n * @return {?}\n */\nstatic minProperties(minProperties: number): IValidatorFn {\r\n    return (control: AbstractControl, invert: boolean = false): PlainObject => {\r\n      if (isEmpty(control.value)) { return null; }\r\n      let /** @type {?} */ actualProperties: number = Object.keys(control.value).length || 0;\r\n      let /** @type {?} */ isValid: boolean = actualProperties >= minProperties;\r\n      return xor(isValid, invert) ?\r\n        null : { 'minProperties': { minProperties, actualProperties } };\r\n    };\r\n  }\n/**\n * 'maxProperties' validator\r\rRequires a form group to have a maximum number of properties (i.e. have\rvalues entered in a maximum number of controls within the group).\r\rNote: Has no effect if the form group does not contain more than the\rmaximum number of controls.\r\r\\@param {number} maxProperties - maximum number of properties allowed\r\\@return {IValidatorFn}\n * @param {?} maxProperties\n * @return {?}\n */\nstatic maxProperties(maxProperties: number): IValidatorFn {\r\n    return (control: AbstractControl, invert: boolean = false): PlainObject => {\r\n      let /** @type {?} */ actualProperties: number = Object.keys(control.value).length || 0;\r\n      let /** @type {?} */ isValid: boolean = actualProperties <= maxProperties;\r\n      return xor(isValid, invert) ?\r\n        null : { 'maxProperties': { maxProperties, actualProperties } };\r\n    };\r\n  }\n/**\n * 'dependencies' validator\r\rRequires the controls in a form group to meet additional validation\rcriteria, depending on the values of other controls in the group.\r\rExamples:\rhttps://spacetelescope.github.io/understanding-json-schema/reference/object.html#dependencies\r\r\\@param {any} dependencies - required dependencies\r\\@return {IValidatorFn}\n * @param {?} dependencies\n * @return {?}\n */\nstatic dependencies(dependencies: any): IValidatorFn {\r\n    return (control: AbstractControl, invert: boolean = false): PlainObject => {\r\n      if (isEmpty(control.value)) { return null; }\r\n      if (getType(dependencies) !== 'object' || isEmpty(dependencies)) { return null; }\r\n      let /** @type {?} */ allErrors: PlainObject = _mergeObjects(\r\n        forEachCopy(dependencies, (value, requiringField) => {\r\n          if (!hasValue(control.value[requiringField])) { return null; }\r\n          let /** @type {?} */ requiringFieldErrors: PlainObject = { };\r\n          let /** @type {?} */ requiredFields: string[];\r\n          let /** @type {?} */ properties: PlainObject = { };\r\n          if (getType(dependencies[requiringField]) === 'array') {\r\n            requiredFields = dependencies[requiringField];\r\n          } else if (getType(dependencies[requiringField]) === 'object') {\r\n            requiredFields = dependencies[requiringField]['required'] || [];\r\n            properties = dependencies[requiringField]['properties'] || { };\r\n          }\r\n\r\n          // Validate property dependencies\r\n          for (let /** @type {?} */ requiredField of requiredFields) {\r\n            if (xor(!hasValue(control.value[requiredField]), invert)) {\r\n              requiringFieldErrors[requiredField] = { 'required': true };\r\n            }\r\n          }\r\n\r\n          // Validate schema dependencies\r\n          requiringFieldErrors = _mergeObjects(requiringFieldErrors,\r\n            forEachCopy(properties, (requirements, requiredField) => {\r\n              let /** @type {?} */ requiredFieldErrors: PlainObject = _mergeObjects(\r\n                forEachCopy(requirements, (requirement, parameter) => {\r\n                  let /** @type {?} */ validator: IValidatorFn = null;\r\n                  if (requirement === 'maximum' || requirement === 'minimum') {\r\n                    let /** @type {?} */ exclusive: boolean =\r\n                      !!requirements['exclusiveM' + requirement.slice(1)];\r\n                    validator = JsonValidators[requirement](parameter, exclusive);\r\n                  } else if (typeof JsonValidators[requirement] === 'function') {\r\n                    validator = JsonValidators[requirement](parameter);\r\n                  }\r\n                  return !isDefined(validator) ?\r\n                    null : validator(control.value[requiredField]);\r\n                })\r\n              );\r\n              return isEmpty(requiredFieldErrors) ?\r\n                null : { [requiredField]: requiredFieldErrors };\r\n            })\r\n          );\r\n          return isEmpty(requiringFieldErrors) ?\r\n            null : { [requiringField]: requiringFieldErrors };\r\n        })\r\n      );\r\n      return isEmpty(allErrors) ? null : allErrors;\r\n    };\r\n  }\n/**\n * 'minItems' validator\r\rRequires a form array to have a minimum number of values.\r\r\\@param {number} minItems - minimum number of items allowed\r\\@return {IValidatorFn}\n * @param {?} minItems\n * @return {?}\n */\nstatic minItems(minItems: number): IValidatorFn {\r\n    return (control: AbstractControl, invert: boolean = false): PlainObject => {\r\n      if (isEmpty(control.value)) { return null; }\r\n      let /** @type {?} */ actualItems: number = isArray(control.value) ? control.value.length : 0;\r\n      let /** @type {?} */ isValid: boolean = actualItems >= minItems;\r\n      return xor(isValid, invert) ?\r\n        null : { 'minItems': { minItems, actualItems } };\r\n    };\r\n  }\n/**\n * 'maxItems' validator\r\rRequires a form array to have a maximum number of values.\r\r\\@param {number} maxItems - maximum number of items allowed\r\\@return {IValidatorFn}\n * @param {?} maxItems\n * @return {?}\n */\nstatic maxItems(maxItems: number): IValidatorFn {\r\n    return (control: AbstractControl, invert: boolean = false): PlainObject => {\r\n      let /** @type {?} */ actualItems: number = isArray(control.value) ? control.value.length : 0;\r\n      let /** @type {?} */ isValid: boolean = actualItems <= maxItems;\r\n      return xor(isValid, invert) ?\r\n        null : { 'maxItems': { maxItems, actualItems } };\r\n    };\r\n  }\n/**\n * 'uniqueItems' validator\r\rRequires values in a form array to be unique.\r\r\\@param {boolean = true} unique? - true to validate, false to disable\r\\@return {IValidatorFn}\n * @param {?=} unique\n * @return {?}\n */\nstatic uniqueItems(unique: boolean = true): IValidatorFn {\r\n    return (control: AbstractControl, invert: boolean = false): PlainObject => {\r\n      if (!unique) { return null; }\r\n      if (isEmpty(control.value)) { return null; }\r\n      let /** @type {?} */ sorted: any[] = control.value.slice().sort();\r\n      let /** @type {?} */ duplicateItems = [];\r\n      for (let /** @type {?} */ i = 1, /** @type {?} */ l = sorted.length; i < l; i++) {\r\n        if (sorted[i - 1] === sorted[i] &&\r\n          duplicateItems.indexOf(sorted[i]) !== -1\r\n        ) {\r\n          duplicateItems.push(sorted[i]);\r\n        }\r\n      }\r\n      let /** @type {?} */ isValid: boolean = !duplicateItems.length;\r\n      return xor(isValid, invert) ?\r\n        null : { 'uniqueItems': { duplicateItems } };\r\n    };\r\n  }\n/**\n * No-op validator. Included for backward compatibility.\n * @param {?} c\n * @return {?}\n */\nstatic nullValidator(c: AbstractControl): PlainObject { return null; }\n/**\n * 'composeAnyOf' validator combination function\r\rAccepts an array of validators and returns a single validator that\revaluates to valid if any one or more of the submitted validators are\rvalid. If every validator is invalid, it returns combined errors from\rall validators.\r\r\\@param {IValidatorFn[]} validators - array of validators to combine\r\\@return {IValidatorFn} - single combined validator function\n * @param {?} validators\n * @return {?}\n */\nstatic composeAnyOf(validators: IValidatorFn[]): IValidatorFn {\r\n    if (!validators) { return null; }\r\n    let /** @type {?} */ presentValidators: IValidatorFn[] = validators.filter(isDefined);\r\n    if (presentValidators.length === 0) { return null; }\r\n    return (control: AbstractControl, invert: boolean = false): PlainObject => {\r\n      let /** @type {?} */ arrayOfErrors: PlainObject[] =\r\n        _executeValidators(control, presentValidators, invert).filter(isDefined);\r\n      let /** @type {?} */ isValid: boolean = validators.length > arrayOfErrors.length;\r\n      return xor(isValid, invert) ?\r\n        null : _mergeObjects.apply(arrayOfErrors.concat({ 'anyOf': !invert }));\r\n    };\r\n  }\n/**\n * 'composeOneOf' validator combination function\r\rAccepts an array of validators and returns a single validator that\revaluates to valid only if exactly one of the submitted validators\ris valid. Otherwise returns combined information from all validators,\rboth valid and invalid.\r\r\\@param {IValidatorFn[]} validators - array of validators to combine\r\\@return {IValidatorFn} - single combined validator function\n * @param {?} validators\n * @return {?}\n */\nstatic composeOneOf(validators: IValidatorFn[]): IValidatorFn {\r\n    if (!validators) { return null; }\r\n    let /** @type {?} */ presentValidators: IValidatorFn[] = validators.filter(isDefined);\r\n    if (presentValidators.length === 0) { return null; }\r\n    return (control: AbstractControl, invert: boolean = false): PlainObject => {\r\n      let /** @type {?} */ arrayOfErrors: PlainObject[] =\r\n        _executeValidators(control, presentValidators);\r\n      let /** @type {?} */ validControls: number =\r\n        validators.length - arrayOfErrors.filter(isDefined).length;\r\n      let /** @type {?} */ isValid: boolean = validControls === 1;\r\n      if (xor(isValid, invert)) { return null; }\r\n      let /** @type {?} */ arrayOfValids: PlainObject[] =\r\n        _executeValidators(control, presentValidators, invert);\r\n      return _mergeObjects.apply(\r\n        arrayOfErrors.concat(arrayOfValids).concat({ 'oneOf': !invert })\r\n      );\r\n    };\r\n  }\n/**\n * 'composeAllOf' validator combination function\r\rAccepts an array of validators and returns a single validator that\revaluates to valid only if all the submitted validators are individually\rvalid. Otherwise it returns combined errors from all invalid validators.\r\r\\@param {IValidatorFn[]} validators - array of validators to combine\r\\@return {IValidatorFn} - single combined validator function\n * @param {?} validators\n * @return {?}\n */\nstatic composeAllOf(validators: IValidatorFn[]): IValidatorFn {\r\n    if (!validators) { return null; }\r\n    let /** @type {?} */ presentValidators: IValidatorFn[] = validators.filter(isDefined);\r\n    if (presentValidators.length === 0) { return null; }\r\n    return (control: AbstractControl, invert: boolean = false): PlainObject => {\r\n      let /** @type {?} */ combinedErrors = _mergeErrors(\r\n        _executeValidators(control, presentValidators, invert)\r\n      );\r\n      let /** @type {?} */ isValid: boolean = combinedErrors === null;\r\n      return (xor(isValid, invert)) ?\r\n        null : _mergeObjects(combinedErrors, { 'allOf': !invert });\r\n    };\r\n  }\n/**\n * 'composeNot' validator inversion function\r\rAccepts a single validator function and inverts its result.\rReturns valid if the submitted validator is invalid, and\rreturns invalid if the submitted validator is valid.\r(Note: this function can itself be inverted\r- e.g. composeNot(composeNot(validator)) -\rbut this can be confusing and is therefore not recommended.)\r\r\\@param {IValidatorFn[]} validators - validator(s) to invert\r\\@return {IValidatorFn} - new validator function that returns opposite result\n * @param {?} validator\n * @return {?}\n */\nstatic composeNot(validator: IValidatorFn): IValidatorFn {\r\n    return (control: AbstractControl, invert: boolean = false): PlainObject => {\r\n      if (isEmpty(control.value)) { return null; }\r\n      let /** @type {?} */ error: PlainObject = validator(control, !invert);\r\n      let /** @type {?} */ isValid: boolean = error === null;\r\n      return (xor(isValid, invert)) ?\r\n        null : _mergeObjects(error, { 'not': !invert });\r\n    };\r\n  }\n/**\n * 'compose' validator combination function\r\r\\@param {IValidatorFn[]} validators - array of validators to combine\r\\@return {IValidatorFn} - single combined validator function\n * @param {?} validators\n * @return {?}\n */\nstatic compose(validators: IValidatorFn[]): IValidatorFn {\r\n    if (!validators) { return null; }\r\n    let /** @type {?} */ presentValidators = validators.filter(isDefined);\r\n    if (presentValidators.length === 0) { return null; }\r\n    return (control: AbstractControl, invert: boolean = false): PlainObject =>\r\n      _mergeErrors(_executeValidators(control, presentValidators, invert));\r\n  };\n/**\n * 'composeAsync' async validator combination function\r\r\\@param {AsyncIValidatorFn[]} async validators - array of async validators\r\\@return {AsyncIValidatorFn} - single combined async validator function\n * @param {?} validators\n * @return {?}\n */\nstatic composeAsync(validators: AsyncIValidatorFn[]): AsyncIValidatorFn {\r\n    if (!validators) { return null; }\r\n    let /** @type {?} */ presentValidators = validators.filter(isDefined);\r\n    if (presentValidators.length === 0) { return null; }\r\n    return (control: AbstractControl, invert: boolean = false) => Promise.all(\r\n      _executeAsyncValidators(control, presentValidators).map(_convertToPromise)\r\n    ).then(_mergeErrors);\r\n  }\r\n}\r\n"]}