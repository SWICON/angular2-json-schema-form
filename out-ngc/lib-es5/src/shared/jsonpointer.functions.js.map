{"version":3,"sources":["../../../lib/src/shared/jsonpointer.functions.ts"],"names":[],"mappings":"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","file":"jsonpointer.functions.js","sourceRoot":"","sourcesContent":["import { Injectable } from '@angular/core';\r\n\r\nimport { isDefined, isEmpty, isObject, isArray, isMap } from './validator.functions';\r\nimport { hasOwn, copy } from './utility.functions';\r\n\r\n/**\r\n * 'JsonPointer' class\r\n *\r\n * Some utilities for using JSON Pointers with JSON objects\r\n * https://tools.ietf.org/html/rfc6901\r\n *\r\n * get, getFirst, set, setCopy, insert, insertCopy, remove, has, dict,\r\n * forEachDeep, forEachDeepCopy, escape, unescape, parse, compile, toKey,\r\n * isJsonPointer, isSubPointer, toIndexedPointer, toGenericPointer,\r\n * toControlPointer, parseObjectPath\r\n *\r\n * Partly based on manuelstofer's json-pointer utilities\r\n * https://github.com/manuelstofer/json-pointer\r\n */\r\nexport type Pointer = string | string[];\nexport class JsonPointer {\n/**\n * 'get' function\r\rUses a JSON Pointer to retrieve a value from an object\r\r\\@param {object} object - Object to get value from\r\\@param {Pointer} pointer - JSON Pointer (string or array)\r\\@param {number = 0} startSlice - Zero-based index of first Pointer key to use\r\\@param {number} endSlice - Zero-based index of last Pointer key to use\r\\@param {boolean = false} getBoolean - Return only true or false?\r\\@param {boolean = true} errors - Show error if not found?\r\\@return {object} - Located value (or true or false if getBoolean = true)\n * @param {?} object\n * @param {?} pointer\n * @param {?=} startSlice\n * @param {?=} endSlice\n * @param {?=} getBoolean\n * @param {?=} errors\n * @return {?}\n */\nstatic get(\r\n    object: any, pointer: Pointer, startSlice: number = 0,\r\n    endSlice: number = null, getBoolean: boolean = false, errors: boolean = false\r\n  ): any {\r\n    if (object === null) { return getBoolean ? false : undefined; }\r\n    let /** @type {?} */ keyArray: any[] = this.parse(pointer);\r\n    if (typeof object === 'object' && keyArray !== null) {\r\n      let /** @type {?} */ subObject = object;\r\n      if (startSlice >= keyArray.length || endSlice <= -keyArray.length) { return object; }\r\n      if (startSlice <= -keyArray.length) { startSlice = 0; }\r\n      if (!isDefined(endSlice) || endSlice >= keyArray.length) { endSlice = keyArray.length; }\r\n      keyArray = keyArray.slice(startSlice, endSlice);\r\n      for (let /** @type {?} */ key of keyArray) {\r\n        if (key === '-' && isArray(subObject) && subObject.length) {\r\n          key = subObject.length - 1;\r\n        }\r\n        if (typeof subObject === 'object' && subObject !== null &&\r\n          hasOwn(subObject, key)\r\n        ) {\r\n          subObject = subObject[key];\r\n        } else if (isMap(subObject) && subObject.has(key)) {\r\n          subObject = subObject.get(key);\r\n        } else {\r\n          if (errors) {\r\n            console.error('get error: \"' + key + '\" key not found in object.');\r\n            console.error(pointer);\r\n            console.error(object);\r\n          }\r\n          return getBoolean ? false : undefined;\r\n        }\r\n      }\r\n      return getBoolean ? true : subObject;\r\n    }\r\n    if (errors && keyArray === null) {\r\n      console.error('get error: Invalid JSON Pointer: ' + pointer);\r\n    }\r\n    if (errors && typeof object !== 'object') {\r\n      console.error('get error: Invalid object:=');\r\n      console.error(object);\r\n    }\r\n    return getBoolean ? false : undefined;\r\n  }\n/**\n * 'getFirst' function\r\rTakes an array of JSON Pointers and objects, and returns the value\rfrom the first pointer to find a value in its object.\r\r\\@param {[object, pointer][]} items - array of objects and pointers to check\r\\@param {any} defaultValue - Optional value to return if nothing found\r\\@return {any} - first set value\n * @param {?} items\n * @param {?=} defaultValue\n * @return {?}\n */\nstatic getFirst(items: any, defaultValue: any = null): any {\r\n    if (isEmpty(items)) { return; }\r\n    if (isArray(items)) {\r\n      for (let /** @type {?} */ item of items) {\r\n        if (isEmpty(item)) { continue; }\r\n        if (isArray(item) && item.length >= 2) {\r\n          if (isEmpty(item[0]) || isEmpty(item[1])) { continue; }\r\n          const /** @type {?} */ value: any = this.get(item[0], item[1]);\r\n          if (value) { return value; }\r\n          continue;\r\n        }\r\n        console.error('getFirst error: Input not in correct format.\\n' +\r\n          'Should be: [ [ object1, pointer1 ], [ object 2, pointer2 ], etc... ]');\r\n        return;\r\n      }\r\n      return defaultValue;\r\n    }\r\n    if (isMap(items)) {\r\n      for (let [object, pointer] of items) {\r\n        if (object === null || !this.isJsonPointer(pointer)) { continue; }\r\n        const /** @type {?} */ value: any = this.get(object, pointer);\r\n        if (value) { return value; }\r\n      }\r\n      return defaultValue;\r\n    }\r\n    console.error('getFirst error: Input not in correct format.\\n' +\r\n      'Should be: [ [ object1, pointer1 ], [ object 2, pointer2 ], etc... ]');\r\n  }\n/**\n * 'set' function\r\rUses a JSON Pointer to set a value on an object\r\rIf the optional fourth parameter is TRUE and the inner-most container\ris an array, the function will insert the value as a new item at the\rspecified location in the array, rather than overwriting the existing value\r\r\\@param {object} object - The object to set value in\r\\@param {Pointer} pointer - The JSON Pointer (string or array)\r\\@param {any} value - The value to set\r\\@return {object} - The original object, modified with the set value\n * @param {?} object\n * @param {?} pointer\n * @param {?} value\n * @param {?=} insert\n * @return {?}\n */\nstatic set(\r\n    object: any, pointer: Pointer, value: any, insert: boolean = false\r\n  ): any {\r\n    const /** @type {?} */ keyArray: string[] = this.parse(pointer);\r\n    if (keyArray !== null) {\r\n      let /** @type {?} */ subObject: any = object;\r\n      for (let /** @type {?} */ i = 0, /** @type {?} */ l = keyArray.length - 1; i < l; ++i) {\r\n        let /** @type {?} */ key: string = keyArray[i];\r\n        if (key === '-' && isArray(subObject)) {\r\n          key = subObject.length;\r\n        }\r\n        if (isMap(subObject) && subObject.has(key)) {\r\n          subObject = subObject.get(key);\r\n        } else {\r\n          if (!hasOwn(subObject, key)) {\r\n            subObject[key] = (keyArray[i + 1].match(/^(\\d+|-)$/)) ? [] : {};\r\n          }\r\n          subObject = subObject[key];\r\n        }\r\n      }\r\n      let /** @type {?} */ lastKey: string = keyArray[keyArray.length - 1];\r\n      if (isArray(subObject) && lastKey === '-') {\r\n        subObject.push(value);\r\n      } else if (insert && isArray(subObject) && !isNaN(+lastKey)) {\r\n        subObject.splice(lastKey, 0, value);\r\n      } else if (isMap(subObject)) {\r\n        subObject.set(lastKey, value);\r\n      } else {\r\n        subObject[lastKey] = value;\r\n      }\r\n      return object;\r\n    }\r\n    console.error('set error: Invalid JSON Pointer: ' + pointer);\r\n  }\n/**\n * 'setCopy' function\r\rCopies an object and uses a JSON Pointer to set a value on the copy.\r\rIf the optional fourth parameter is TRUE and the inner-most container\ris an array, the function will insert the value as a new item at the\rspecified location in the array, rather than overwriting the existing value.\r\r\\@param {object} object - The object to copy and set value in\r\\@param {Pointer} pointer - The JSON Pointer (string or array)\r\\@param {any} value - The value to set\r\\@return {object} - The new object with the set value\n * @param {?} object\n * @param {?} pointer\n * @param {?} value\n * @param {?=} insert\n * @return {?}\n */\nstatic setCopy(\r\n    object: any, pointer: Pointer, value: any, insert: boolean = false\r\n  ): any {\r\n    const /** @type {?} */ keyArray: string[] = this.parse(pointer);\r\n    if (keyArray !== null) {\r\n      let /** @type {?} */ newObject: any = copy(object);\r\n      let /** @type {?} */ subObject: any = newObject;\r\n      for (let /** @type {?} */ i = 0, /** @type {?} */ l = keyArray.length - 1; i < l; ++i) {\r\n        let /** @type {?} */ key: string = keyArray[i];\r\n        if (key === '-' && isArray(subObject)) {\r\n          key = subObject.length;\r\n        }\r\n        if (isMap(subObject) && subObject.has(key)) {\r\n          subObject.set(key, copy(subObject.get(key)));\r\n          subObject = subObject.get(key);\r\n        } else {\r\n          if (!hasOwn(subObject, key)) {\r\n            subObject[key] = (keyArray[i + 1].match(/^(\\d+|-)$/)) ? [] : {};\r\n          }\r\n          subObject[key] = copy(subObject[key]);\r\n          subObject = subObject[key];\r\n        }\r\n      }\r\n      let /** @type {?} */ lastKey: string = keyArray[keyArray.length - 1];\r\n      if (isArray(subObject) && lastKey === '-') {\r\n        subObject.push(value);\r\n      } else if (insert && isArray(subObject) && !isNaN(+lastKey)) {\r\n        subObject.splice(lastKey, 0, value);\r\n      } else if (isMap(subObject)) {\r\n        subObject.set(lastKey, value);\r\n      } else {\r\n        subObject[lastKey] = value;\r\n      }\r\n      return newObject;\r\n    }\r\n    console.error('setCopy error: Invalid JSON Pointer: ' + pointer);\r\n  }\n/**\n * 'insert' function\r\rCalls 'set' with insert = TRUE\r\r\\@param {object} object - object to insert value in\r\\@param {Pointer} pointer - JSON Pointer (string or array)\r\\@param {any} value - value to insert\r\\@return {object}\n * @param {?} object\n * @param {?} pointer\n * @param {?} value\n * @return {?}\n */\nstatic insert(object: any, pointer: Pointer, value: any): any {\r\n    this.set(object, pointer, value, true);\r\n  }\n/**\n * 'insertCopy' function\r\rCalls 'setCopy' with insert = TRUE\r\r\\@param {object} object - object to insert value in\r\\@param {Pointer} pointer - JSON Pointer (string or array)\r\\@param {any} value - value to insert\r\\@return {object}\n * @param {?} object\n * @param {?} pointer\n * @param {?} value\n * @return {?}\n */\nstatic insertCopy(object: any, pointer: Pointer, value: any): any {\r\n    this.setCopy(object, pointer, value, true);\r\n  }\n/**\n * 'remove' function\r\rUses a JSON Pointer to remove a key and its attribute from an object\r\r\\@param {object} object - object to delete attribute from\r\\@param {Pointer} pointer - JSON Pointer (string or array)\r\\@return {object}\n * @param {?} object\n * @param {?} pointer\n * @return {?}\n */\nstatic remove(object: any, pointer: Pointer): any {\r\n    let /** @type {?} */ keyArray: any[] = this.parse(pointer);\r\n    if (keyArray !== null && keyArray.length) {\r\n      let /** @type {?} */ lastKey = keyArray.pop();\r\n      let /** @type {?} */ parentObject = this.get(object, keyArray);\r\n      if (isArray(parentObject)) {\r\n        if (lastKey === '-') { lastKey = parentObject.length - 1; }\r\n        parentObject.splice(lastKey, 1);\r\n      } else if (isObject(parentObject)) {\r\n        delete parentObject[lastKey];\r\n      }\r\n      return object;\r\n    }\r\n    console.error('remove error: Invalid JSON Pointer: ' + pointer);\r\n  }\n/**\n * 'has' function\r\rTests if an object has a value at the location specified by a JSON Pointer\r\r\\@param {object} object - object to chek for value\r\\@param {Pointer} pointer - JSON Pointer (string or array)\r\\@return {boolean}\n * @param {?} object\n * @param {?} pointer\n * @return {?}\n */\nstatic has(object: any, pointer: Pointer): boolean {\r\n    return this.get(object, pointer, 0, null, true);\r\n  }\n/**\n * 'dict' function\r\rReturns a (pointer -> value) dictionary for an object\r\r\\@param {Object} object - The object to create a dictionary from\r\\@return {Object} - The resulting dictionary object\n * @param {?} object\n * @return {?}\n */\nstatic dict(object: any): any {\r\n    let /** @type {?} */ results: any = {};\r\n    this.forEachDeep(object, (value, pointer) => {\r\n      if (typeof value !== 'object') { results[pointer] = value; }\r\n    });\r\n    return results;\r\n  }\n/**\n * 'forEachDeep' function\r\rIterates over own enumerable properties of an object or items in an array\rand invokes an iteratee function for each key/value or index/value pair.\rBy default, iterates over items within objects and arrays after calling\rthe iteratee function on the containing object or array itself.\r\rThe iteratee is invoked with three arguments: (value, pointer, rootObject),\rwhere pointer is a JSON pointer indicating the location of the current\rvalue within the root object, and rootObject is the root object initially\rsubmitted to th function.\r\rIf a third optional parameter 'bottomUp' is set to TRUE, the iterator\rfunction will be called on sub-objects and arrays after being\rcalled on their contents, rather than before, which is the default.\r\rThis function can also optionally be called directly on a sub-object by\rincluding optional 4th and 5th parameterss to specify the initial\rroot object and pointer.\r\r\\@param {object} object - the initial object or array\r\\@param {(v: any, k?: string, o?: any, p?: any) => any} function - iteratee function\r\\@param {boolean = false} bottomUp - optional, set to TRUE to reverse direction\r\\@param {object = object} rootObject - optional, root object or array\r\\@param {string = ''} pointer - optional, JSON Pointer to object within rootObject\n * @param {?} object\n * @param {?} fn\n * @param {?=} bottomUp\n * @param {?=} pointer\n * @param {?=} rootObject\n * @return {?}\n */\nstatic forEachDeep(\r\n    object: any, fn: (v: any, p?: string, o?: any) => any,\r\n    bottomUp: boolean = false, pointer: string = '', rootObject: any = object\r\n  ): void {\r\n    if (typeof fn === 'function') {\r\n      if (!bottomUp) { fn(object, pointer, rootObject); }\r\n      if (isObject(object) || isArray(object)) {\r\n        for (let /** @type {?} */ key of Object.keys(object)) {\r\n          const /** @type {?} */ newPointer: string = pointer + '/' + this.escape(key);\r\n          this.forEachDeep(object[key], fn, bottomUp, newPointer, rootObject);\r\n        }\r\n      }\r\n      if (bottomUp) { fn(object, pointer, rootObject); }\r\n    } else {\r\n      console.error('forEachDeep error: Iterator must be a function.');\r\n    }\r\n  }\n/**\n * 'forEachDeepCopy' function\r\rSimilar to forEachDeep, but returns a copy of the original object, with\rthe same keys and indexes, but with values replaced with the result of\rthe iteratee function.\r\r\\@param {object} object - the initial object or array\r\\@param {(v: any, k?: string, o?: any, p?: any) => any} function - iteratee function\r\\@param {boolean = false} bottomUp - optional, set to TRUE to reverse direction\r\\@param {object = object} rootObject - optional, root object or array\r\\@param {string = ''} pointer - optional, JSON Pointer to object within rootObject\n * @param {?} object\n * @param {?} fn\n * @param {?=} bottomUp\n * @param {?=} pointer\n * @param {?=} rootObject\n * @return {?}\n */\nstatic forEachDeepCopy(\r\n    object: any, fn: (v: any, p?: string, o?: any) => any,\r\n    bottomUp: boolean = false, pointer: string = '', rootObject: any = object\r\n  ): void {\r\n    if (typeof fn === 'function') {\r\n      if (isObject(object) || isArray(object)) {\r\n        let /** @type {?} */ newObject = Object.assign(isArray(object) ? [] : {}, object);\r\n        if (!bottomUp) { fn(newObject, pointer, rootObject); }\r\n        for (let /** @type {?} */ key of Object.keys(newObject)) {\r\n          const /** @type {?} */ newPointer: string = pointer + '/' + this.escape(key);\r\n          newObject[key] = this.forEachDeepCopy(object[key], fn, bottomUp, newPointer, rootObject);\r\n        }\r\n        if (bottomUp) { fn(newObject, pointer, rootObject); }\r\n      } else {\r\n        return fn(object, pointer, rootObject);\r\n      }\r\n    }\r\n    console.error('forEachDeep error: Iterator must be a function.');\r\n  }\n/**\n * 'escape' function\r\rEscapes a string reference key\r\r\\@param {string} key - string key to escape\r\\@return {string} - escaped key\n * @param {?} key\n * @return {?}\n */\nstatic escape(key: string): string {\r\n    return key.toString().replace(/~/g, '~0').replace(/\\//g, '~1');\r\n  }\n/**\n * 'unescape' function\rUnescapes a string reference key\r\r\\@param {string} key - string key to unescape\r\\@return {string} - unescaped key\n * @param {?} key\n * @return {?}\n */\nstatic unescape(key: string): string {\r\n    return key.toString().replace(/~1/g, '/').replace(/~0/g, '~');\r\n  }\n/**\n * 'parse' function\r\rConverts a string JSON Pointer into a array of keys\r(if input is already an an array of keys, it is returned unchanged)\r\r\\@param {Pointer} pointer - JSON Pointer (string or array)\r\\@return {string[]} - JSON Pointer array of keys\n * @param {?} pointer\n * @return {?}\n */\nstatic parse(pointer: Pointer): string[] {\r\n    if (isArray(pointer)) { return /** @type {?} */(( <string[]>pointer)); }\r\n    if (typeof pointer === 'string') {\r\n      if (( /** @type {?} */((<string>pointer)))[0] === '#') { pointer = pointer.slice(1); }\r\n      if ( /** @type {?} */((<string>pointer)) === '') { return []; }\r\n      if (( /** @type {?} */((<string>pointer)))[0] !== '/') {\r\n        console.error('parse error: Invalid JSON Pointer, does not start with \"/\": ' +\r\n          pointer);\r\n        return;\r\n      }\r\n      return ( /** @type {?} */((<string>pointer))).slice(1).split('/').map(this.unescape);\r\n    }\r\n    console.error('parse error: Invalid JSON Pointer, not a string or array:');\r\n    console.error(pointer);\r\n  }\n/**\n * 'compile' function\r\rConverts an array of keys into a JSON Pointer string\r(if input is already a string, it is normalized and returned)\r\rThe optional second parameter is a default which will replace any empty keys.\r\r\\@param {Pointer} keyArray - JSON Pointer (string or array)\r\\@returns {string} - JSON Pointer string\n * @param {?} keyArray\n * @param {?=} defaultValue\n * @return {?}\n */\nstatic compile(keyArray: Pointer, defaultValue: string | number = ''): string {\r\n    if (isArray(keyArray)) {\r\n      if (( /** @type {?} */((<string[]>keyArray))).length === 0) { return ''; }\r\n      return '/' + ( /** @type {?} */((<string[]>keyArray))).map(\r\n        key => key === '' ? defaultValue : this.escape(key)\r\n      ).join('/');\r\n    }\r\n    if (typeof keyArray === 'string') {\r\n      if (keyArray[0] === '#') { keyArray = keyArray.slice(1); }\r\n      if (keyArray.length && keyArray[0] !== '/') {\r\n        console.error('compile error: Invalid JSON Pointer, does not start with \"/\": ' +\r\n          keyArray);\r\n        return;\r\n      }\r\n      return keyArray;\r\n    }\r\n    console.error('compile error: Invalid JSON Pointer, not a string or array:');\r\n    console.error(keyArray);\r\n  }\n/**\n * 'toKey' function\r\rExtracts name of the final key from a JSON Pointer.\r\r\\@param {Pointer} pointer - JSON Pointer (string or array)\r\\@returns {string} - the extracted key\n * @param {?} pointer\n * @return {?}\n */\nstatic toKey(pointer: Pointer): string {\r\n    let /** @type {?} */ keyArray = this.parse(pointer);\r\n    if (keyArray === null) { return null; }\r\n    if (!keyArray.length) { return ''; }\r\n    return keyArray[keyArray.length - 1];\r\n  }\n/**\n * 'isJsonPointer' function\r\rChecks a string value to determine if it is a valid JSON Pointer.\rThis function only checks for valid JSON Pointer strings, not arrays.\r(Any array of string values is assumed to be a potentially valid JSON Pointer.)\r\r\\@param {any} value - value to check\r\\@returns {boolean} - true if value is a valid JSON Pointer, otherwise false\n * @param {?} value\n * @return {?}\n */\nstatic isJsonPointer(value: any): boolean {\r\n    if (typeof value === 'string') {\r\n      if (value === '') { return true; }\r\n      if (value[0] === '#') { value = value.slice(1); }\r\n      if (value[0] === '/') { return true; }\r\n    }\r\n    return false;\r\n  }\n/**\n * 'isSubPointer' function\r\rChecks whether one JSON Pointer is a subset of another.\r\r\\@param {Pointer} shortPointer - potential subset JSON Pointer\r\\@param {Pointer} longPointer - potential superset JSON Pointer\r\\@return {boolean} - true if shortPointer is a subset of longPointer, false if not\n * @param {?} shortPointer\n * @param {?} longPointer\n * @return {?}\n */\nstatic isSubPointer(shortPointer: Pointer, longPointer: Pointer): boolean {\r\n    if (isArray(shortPointer)) { shortPointer = this.compile(shortPointer); }\r\n    if (isArray(longPointer)) { longPointer = this.compile(longPointer); }\r\n    if (typeof shortPointer !== 'string' || typeof longPointer !== 'string') {\r\n      console.error('isSubPointer error: Invalid JSON Pointer, not a string or array:');\r\n      if (typeof shortPointer !== 'string') { console.error(shortPointer); }\r\n      if (typeof longPointer !== 'string') { console.error(longPointer); }\r\n      return;\r\n    }\r\n    return shortPointer === longPointer.slice(0, shortPointer.length);\r\n  }\n/**\n * 'toIndexedPointer' function\r\rMerges an array of numeric indexes and a generic pointer to create an\rindexed pointer for a specific item.\r\rFor example, merging the generic pointer '/foo/-/bar/-/baz' and\rthe array [4, 2] would result in the indexed pointer '/foo/4/bar/2/baz'\r\r\\@function\r\\@param {string | string[]} genericPointer - The generic pointer\r\\@param {number[]} indexArray - The array of numeric indexes\r\\@param {Map<string, number>} arrayMap - An optional array map\r\\@return {string} - The merged pointer with indexes\n * @param {?} genericPointer\n * @param {?} indexArray\n * @param {?=} arrayMap\n * @return {?}\n */\nstatic toIndexedPointer(\r\n    genericPointer: string, indexArray: number[], arrayMap: Map<string, number> = null\r\n  ) {\r\n    if (genericPointer[0] === '#') {\r\n      genericPointer = genericPointer.slice(1);\r\n    }\r\n    if (this.isJsonPointer(genericPointer) && isArray(indexArray)) {\r\n      if (isMap(arrayMap)) {\r\n        let /** @type {?} */ arrayIndex: number = 0;\r\n        return genericPointer.replace(/\\/\\-(?=\\/|$)/g, (key, stringIndex) => {\r\n          const /** @type {?} */ subPointer = genericPointer.slice(0, stringIndex);\r\n          if (arrayMap.has(subPointer)) { return '/' + indexArray[arrayIndex++]; }\r\n        });\r\n      } else {\r\n        let /** @type {?} */ indexedPointer = genericPointer;\r\n        for (let /** @type {?} */ pointerIndex of indexArray) {\r\n          indexedPointer = indexedPointer.replace('/-', '/' + pointerIndex);\r\n        }\r\n        return indexedPointer;\r\n      }\r\n    }\r\n    console.error('toIndexedPointer error: genericPointer must be ' +\r\n      'a JSON Pointer and indexArray must be an array.');\r\n    console.error(genericPointer);\r\n    console.error(indexArray);\r\n  };\n/**\n * 'toGenericPointer' function\r\rCompares an indexed pointer to an array map and removes list array\rindexes (but leaves tuple arrray indexes and all object keys, including\rnumeric keys) to create a generic pointer.\r\rFor example, using the indexed pointer '/foo/1/bar/2/baz/3' and\rthe arrayMap [['/foo', 0], ['/foo/-/bar', 3], ['/foo/-/bar/2/baz', 0]]\rwould result in the generic pointer '/foo/-/bar/2/baz/-'\rUsing the indexed pointer '/foo/1/bar/4/baz/3' and the same arrayMap\rwould result in the generic pointer '/foo/-/bar/-/baz/-'\r\rThe structure of the arrayMap is: [['path to array', number of tuple items]...]\r\r\\@function\r\\@param {Pointer} indexedPointer - The indexed pointer (array or string)\r\\@param {Map<string, number>} arrayMap - The optional array map (for preserving tuple indexes)\r\\@return {string} - The generic pointer with indexes removed\n * @param {?} indexedPointer\n * @param {?=} arrayMap\n * @return {?}\n */\nstatic toGenericPointer(\r\n    indexedPointer: Pointer, arrayMap: Map<string, number> = new Map<string, number>()\r\n  ) {\r\n    if (this.isJsonPointer(indexedPointer) && isMap(arrayMap)) {\r\n      let /** @type {?} */ pointerArray = this.parse(indexedPointer);\r\n      for (let /** @type {?} */ i = 1, /** @type {?} */ l = pointerArray.length; i < l; i++) {\r\n        const /** @type {?} */ subPointer = this.compile(pointerArray.slice(0, i));\r\n        if (arrayMap.has(subPointer) && arrayMap.get(subPointer) <= +pointerArray[i]) {\r\n          pointerArray[i] = '-';\r\n        }\r\n      }\r\n      return this.compile(pointerArray);\r\n    }\r\n    console.error('toGenericPointer error: ' +\r\n      'indexedPointer must be a JSON Pointer and arrayMap must be a Map.');\r\n    console.error(indexedPointer);\r\n    console.error(arrayMap);\r\n  };\n/**\n * 'toControlPointer' function\r\rAccepts a JSON Pointer for a data object and returns a JSON Pointer for the\rmatching control in an Angular FormGroup.\r\r\\@param {FormGroup} formGroup - Angular FormGroup to get value from\r\\@param {Pointer} dataPointer - JSON Pointer (string or array) to a data object\r\\@return {Pointer} - JSON Pointer (string) to the formGroup object\n * @param {?} formGroup\n * @param {?} dataPointer\n * @return {?}\n */\nstatic toControlPointer(formGroup: any, dataPointer: Pointer): string {\r\n    const /** @type {?} */ dataPointerArray: string[] = this.parse(dataPointer);\r\n    let /** @type {?} */ controlPointerArray: string[] = [];\r\n    let /** @type {?} */ subGroup = formGroup;\r\n    if (dataPointerArray !== null) {\r\n      for (let /** @type {?} */ key of dataPointerArray) {\r\n        if (subGroup.hasOwnProperty('controls')) {\r\n          controlPointerArray.push('controls');\r\n          subGroup = subGroup.controls;\r\n        }\r\n        if (isArray(subGroup) && (key === '-')) {\r\n          controlPointerArray.push((subGroup.length - 1).toString());\r\n          subGroup = subGroup[subGroup.length - 1];\r\n        } else if (subGroup.hasOwnProperty(key)) {\r\n          controlPointerArray.push(key);\r\n          subGroup = subGroup[key];\r\n        } else {\r\n          console.error('toControlPointer error: Unable to find \"' + key +\r\n            '\" item in FormGroup.');\r\n          console.error(dataPointer);\r\n          console.error(formGroup);\r\n          return;\r\n        }\r\n      }\r\n      return this.compile(controlPointerArray);\r\n    }\r\n    console.error('getControl error: Invalid JSON Pointer: ' + dataPointer);\r\n  }\n/**\n * 'parseObjectPath' function\r\rParses a JavaScript object path into an array of keys, which\rcan then be passed to compile() to convert into a string JSON Pointer.\r\rBased on mike-marcacci's objectpath parse function:\rhttps://github.com/mike-marcacci/objectpath\r\r\\@param {string} path - The object path to parse\r\\@return {string[]} - The resulting array of keys\n * @param {?} path\n * @return {?}\n */\nstatic parseObjectPath(path: string | string[]): string[] {\r\n    if (isArray(path)) { return /** @type {?} */(( <string[]>path)); }\r\n    if (typeof path === 'string') {\r\n      let /** @type {?} */ index: number = 0;\r\n      let /** @type {?} */ parts: string[] = [];\r\n      while (index < path.length) {\r\n        const /** @type {?} */ nextDot: number = path.indexOf('.', index);\r\n        const /** @type {?} */ nextOB: number = path.indexOf('[', index); // next open bracket\r\n        if (nextDot === -1 && nextOB === -1) { // last item\r\n          parts.push(path.slice(index));\r\n          index = path.length;\r\n        } else if (nextDot !== -1 && (nextDot < nextOB || nextOB === -1)) { // dot notation\r\n          parts.push(path.slice(index, nextDot));\r\n          index = nextDot + 1;\r\n        } else { // bracket notation\r\n          if (nextOB > index) {\r\n            parts.push(path.slice(index, nextOB));\r\n            index = nextOB;\r\n          }\r\n          const /** @type {?} */ quote: string = path.charAt(nextOB + 1);\r\n          if (quote === '\"' || quote === \"'\") { // enclosing quotes\r\n            let /** @type {?} */ nextCB: number = path.indexOf(quote + ']', nextOB); // next close bracket\r\n            while (nextCB !== -1 && path.charAt(nextCB - 1) === '\\\\') {\r\n              nextCB = path.indexOf(quote + ']', nextCB + 2);\r\n            }\r\n            if (nextCB === -1) { nextCB = path.length; }\r\n            parts.push(path.slice(index + 2, nextCB)\r\n              .replace(new RegExp('\\\\' + quote, 'g'), quote));\r\n            index = nextCB + 2;\r\n          } else { // no enclosing quotes\r\n            let /** @type {?} */ nextCB: number = path.indexOf(']', nextOB); // next close bracket\r\n            if (nextCB === -1) { nextCB = path.length; }\r\n            parts.push(path.slice(index + 1, nextCB));\r\n            index = nextCB + 1;\r\n          }\r\n          if (path.charAt(index) === '.') { index++; }\r\n        }\r\n      }\r\n      return parts;\r\n    }\r\n    console.error('parseObjectPath error: Input object path must be a string.');\r\n  }\r\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction JsonPointer_tsickle_Closure_declarations() {\n/** @type {?} */\nJsonPointer.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nJsonPointer.ctorParameters;\n}\n\r\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}